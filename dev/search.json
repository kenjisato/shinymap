[
  {
    "objectID": "typescript/variables/sequential.html",
    "href": "typescript/variables/sequential.html",
    "title": "Variable: sequential",
    "section": "",
    "text": "shinymap TypeScript API\nshinymap TypeScript API / sequential"
  },
  {
    "objectID": "typescript/variables/sequential.html#type-declaration",
    "href": "typescript/variables/sequential.html#type-declaration",
    "title": "Variable: sequential",
    "section": "Type Declaration",
    "text": "Type Declaration\n\nblue\n\nblue: string[]\n\n\n\ngreen\n\ngreen: string[]\n\n\n\norange\n\norange: string[]"
  },
  {
    "objectID": "typescript/variables/palette.html",
    "href": "typescript/variables/palette.html",
    "title": "Variable: palette",
    "section": "",
    "text": "shinymap TypeScript API\n\nshinymap TypeScript API / palette\n\nVariable: palette\n\nconst palette: Palette\n\nDefined in: palette.ts:30"
  },
  {
    "objectID": "typescript/type-aliases/TooltipMap.html",
    "href": "typescript/type-aliases/TooltipMap.html",
    "title": "Type Alias: TooltipMap",
    "section": "",
    "text": "shinymap TypeScript API\n\nshinymap TypeScript API / TooltipMap\n\nType Alias: TooltipMap\n\nTooltipMap = Record&lt;RegionId, string&gt;\n\nDefined in: types.ts:139"
  },
  {
    "objectID": "typescript/type-aliases/RegionId.html",
    "href": "typescript/type-aliases/RegionId.html",
    "title": "Type Alias: RegionId",
    "section": "",
    "text": "shinymap TypeScript API\n\nshinymap TypeScript API / RegionId\n\nType Alias: RegionId\n\nRegionId = string\n\nDefined in: types.ts:3"
  },
  {
    "objectID": "typescript/type-aliases/ModeConfig.html",
    "href": "typescript/type-aliases/ModeConfig.html",
    "title": "Type Alias: ModeConfig",
    "section": "",
    "text": "shinymap TypeScript API\nshinymap TypeScript API / ModeConfig"
  },
  {
    "objectID": "typescript/type-aliases/ModeConfig.html#properties",
    "href": "typescript/type-aliases/ModeConfig.html#properties",
    "title": "Type Alias: ModeConfig",
    "section": "Properties",
    "text": "Properties\n\naesIndexed?\n\noptional aesIndexed: AesIndexedConfig\n\nDefined in: types.ts:283\nIndexed aesthetic for multi-state visual feedback (Cycle, Count modes)\n\n\n\nallowDeselect?\n\noptional allowDeselect: boolean\n\nDefined in: types.ts:277\nAllow deselection in single mode\n\n\n\nclickable?\n\noptional clickable: boolean\n\nDefined in: types.ts:285\nEnable click events in display mode. Default is false.\n\n\n\nmaxSelection?\n\noptional maxSelection: number\n\nDefined in: types.ts:279\nMaximum number of regions that can be selected (multiple mode)\n\n\n\nn?\n\noptional n: number\n\nDefined in: types.ts:281\nNumber of states for cycle mode. Counts advance modulo n.\n\n\n\ntype\n\ntype: MapModeType\n\nDefined in: types.ts:275"
  },
  {
    "objectID": "typescript/type-aliases/LayersConfig.html",
    "href": "typescript/type-aliases/LayersConfig.html",
    "title": "Type Alias: LayersConfig",
    "section": "",
    "text": "shinymap TypeScript API\nshinymap TypeScript API / LayersConfig"
  },
  {
    "objectID": "typescript/type-aliases/LayersConfig.html#properties",
    "href": "typescript/type-aliases/LayersConfig.html#properties",
    "title": "Type Alias: LayersConfig",
    "section": "Properties",
    "text": "Properties\n\nhidden?\n\noptional hidden: string[]\n\nDefined in: types.ts:686\nGroup names to hide completely (not rendered).\n\n\n\noverlays?\n\noptional overlays: string[]\n\nDefined in: types.ts:684\nGroup names to render in overlay layer (above base regions).\n\n\n\nunderlays?\n\noptional underlays: string[]\n\nDefined in: types.ts:682\nGroup names to render in underlay layer (below base regions)."
  },
  {
    "objectID": "typescript/type-aliases/AesConfig.html",
    "href": "typescript/type-aliases/AesConfig.html",
    "title": "Type Alias: AesConfig",
    "section": "",
    "text": "shinymap TypeScript API\n\nshinymap TypeScript API / AesConfig\n\nType Alias: AesConfig\n\nAesConfig = LegacyAesConfig | AesPayload\n\nDefined in: types.ts:673\nNested aesthetic configuration (new API).\nAccepts either: - LegacyAesConfig: flat base/select/hover/group structure (React developers) - AesPayload: v0.3 format from Python with __all/_metadata (Shiny apps)"
  },
  {
    "objectID": "typescript/functions/renderInputMap.html",
    "href": "typescript/functions/renderInputMap.html",
    "title": "Function: renderInputMap()",
    "section": "",
    "text": "shinymap TypeScript API\nshinymap TypeScript API / renderInputMap"
  },
  {
    "objectID": "typescript/functions/renderInputMap.html#parameters",
    "href": "typescript/functions/renderInputMap.html#parameters",
    "title": "Function: renderInputMap()",
    "section": "Parameters",
    "text": "Parameters\n\ntarget\nHTMLElement\n\n\nprops\nInputMapProps\n\n\nonChange?\n(value) =&gt; void"
  },
  {
    "objectID": "typescript/functions/renderInputMap.html#returns",
    "href": "typescript/functions/renderInputMap.html#returns",
    "title": "Function: renderInputMap()",
    "section": "Returns",
    "text": "Returns\nRoot"
  },
  {
    "objectID": "typescript/functions/InputMap.html",
    "href": "typescript/functions/InputMap.html",
    "title": "Function: InputMap()",
    "section": "",
    "text": "shinymap TypeScript API\nshinymap TypeScript API / InputMap"
  },
  {
    "objectID": "typescript/functions/InputMap.html#parameters",
    "href": "typescript/functions/InputMap.html#parameters",
    "title": "Function: InputMap()",
    "section": "Parameters",
    "text": "Parameters\n\nprops\nInputMapProps"
  },
  {
    "objectID": "typescript/functions/InputMap.html#returns",
    "href": "typescript/functions/InputMap.html#returns",
    "title": "Function: InputMap()",
    "section": "Returns",
    "text": "Returns\nElement"
  },
  {
    "objectID": "vignettes/index.html",
    "href": "vignettes/index.html",
    "title": "Vignettes",
    "section": "",
    "text": "Tutorials and practical examples for common use cases."
  },
  {
    "objectID": "vignettes/index.html#getting-started",
    "href": "vignettes/index.html#getting-started",
    "title": "Vignettes",
    "section": "Getting Started",
    "text": "Getting Started\n\nGetting Started - Basic setup and first map"
  },
  {
    "objectID": "vignettes/index.html#use-cases",
    "href": "vignettes/index.html#use-cases",
    "title": "Vignettes",
    "section": "Use Cases",
    "text": "Use Cases\nComing soon\n\nCreating a choropleth map\nInteractive region selection\nCustom SVG geometry\nStyling with aesthetics"
  },
  {
    "objectID": "python/update_map.html",
    "href": "python/update_map.html",
    "title": "update_map",
    "section": "",
    "text": "update_map(id, *, aes=None, value=None, tooltips=None, session=None)\nUpdate an input_map or output_map without full re-render.\nFor input_map: Updates aesthetics and selection state. For output_map: Updates aesthetics only (use @render_map for data changes).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nid\nstr\nThe map element ID\nrequired\n\n\naes\nAesType\nAesthetic configuration (ByGroup, ByState, or BaseAesthetic)\nNone\n\n\nvalue\nCountMap\n(input_map only) Selection state; pass {} to clear all selections\nNone\n\n\ntooltips\nTooltipMap\nRegion tooltips\nNone\n\n\nsession\nSession | None\nA Session instance. If not provided, it is inferred via get_current_session()\nNone\n\n\n\n\n\n\nfrom shinymap import aes\nfrom shinymap.ui import update_map\n\n# Update aesthetics with ByGroup (per-region colors)\nupdate_map(\"my_map\", aes=aes.ByGroup(\n    region1=aes.Shape(fill_color=\"#ff0000\"),\n    region2=aes.Shape(fill_color=\"#00ff00\"),\n))\n\n# Update with ByState (base/select/hover)\nupdate_map(\"my_map\", aes=aes.ByState(\n    base=aes.Shape(fill_color=\"#e2e8f0\"),\n    select=aes.Shape(fill_color=\"#bfdbfe\"),\n))\n\n# Clear all selections (input_map only)\nupdate_map(\"my_map\", value={})\n\n# Set specific selections (input_map only)\nupdate_map(\"my_map\", value={\"region1\": 1, \"region2\": 1})\nNote: - Uses shallow merge semantics: new properties override existing ones - Properties not specified are left unchanged - For output_map data updates, use @render_map re-execution instead"
  },
  {
    "objectID": "python/update_map.html#parameters",
    "href": "python/update_map.html#parameters",
    "title": "update_map",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nid\nstr\nThe map element ID\nrequired\n\n\naes\nAesType\nAesthetic configuration (ByGroup, ByState, or BaseAesthetic)\nNone\n\n\nvalue\nCountMap\n(input_map only) Selection state; pass {} to clear all selections\nNone\n\n\ntooltips\nTooltipMap\nRegion tooltips\nNone\n\n\nsession\nSession | None\nA Session instance. If not provided, it is inferred via get_current_session()\nNone"
  },
  {
    "objectID": "python/update_map.html#examples",
    "href": "python/update_map.html#examples",
    "title": "update_map",
    "section": "",
    "text": "from shinymap import aes\nfrom shinymap.ui import update_map\n\n# Update aesthetics with ByGroup (per-region colors)\nupdate_map(\"my_map\", aes=aes.ByGroup(\n    region1=aes.Shape(fill_color=\"#ff0000\"),\n    region2=aes.Shape(fill_color=\"#00ff00\"),\n))\n\n# Update with ByState (base/select/hover)\nupdate_map(\"my_map\", aes=aes.ByState(\n    base=aes.Shape(fill_color=\"#e2e8f0\"),\n    select=aes.Shape(fill_color=\"#bfdbfe\"),\n))\n\n# Clear all selections (input_map only)\nupdate_map(\"my_map\", value={})\n\n# Set specific selections (input_map only)\nupdate_map(\"my_map\", value={\"region1\": 1, \"region2\": 1})\nNote: - Uses shallow merge semantics: new properties override existing ones - Properties not specified are left unchanged - For output_map data updates, use @render_map re-execution instead"
  },
  {
    "objectID": "python/render_map.html",
    "href": "python/render_map.html",
    "title": "render_map",
    "section": "",
    "text": "render_map\nrender_map"
  },
  {
    "objectID": "python/output_map.html",
    "href": "python/output_map.html",
    "title": "output_map",
    "section": "",
    "text": "output_map\noutput_map"
  },
  {
    "objectID": "python/mode.Single.html",
    "href": "python/mode.Single.html",
    "title": "mode.Single",
    "section": "",
    "text": "mode.Single(selected=None, allow_deselect=True, aes=None)\nSingle selection mode with customization options.\nUse when you need options beyond the simple mode=“single” string: - Initial selection - Disable deselection - Custom two-state aesthetics\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nselected\nstr | None\nInitially selected region ID.\nNone\n\n\nallow_deselect\nbool\nIf True (default), clicking selected region deselects it.\nTrue\n\n\naes\nIndexedAesthetic | ByGroup | None\nTwo-state aesthetic [unselected, selected]. Can be aes.Indexed (global) or aes.ByGroup wrapping aes.Indexed.\nNone\n\n\n\n\n\n\n&gt;&gt;&gt; from shinymap.mode import Single\n&gt;&gt;&gt; from shinymap import aes\n\n&gt;&gt;&gt; # Pre-select a region\n&gt;&gt;&gt; mode = Single(selected=\"region_a\")\n\n&gt;&gt;&gt; # Disable deselection (must always have one selected)\n&gt;&gt;&gt; mode = Single(allow_deselect=False)\n\n&gt;&gt;&gt; # Custom selection colors\n&gt;&gt;&gt; mode = Single(\n...     aes=aes.Indexed(\n...         fill_color=[\"#e5e7eb\", \"#3b82f6\"],  # gray -&gt; blue\n...     )\n... )\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_dict\nSerialize for JavaScript (snake_case, JS converts to camelCase).\n\n\n\n\n\nmode.Single.to_dict()\nSerialize for JavaScript (snake_case, JS converts to camelCase)."
  },
  {
    "objectID": "python/mode.Single.html#parameters",
    "href": "python/mode.Single.html#parameters",
    "title": "mode.Single",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nselected\nstr | None\nInitially selected region ID.\nNone\n\n\nallow_deselect\nbool\nIf True (default), clicking selected region deselects it.\nTrue\n\n\naes\nIndexedAesthetic | ByGroup | None\nTwo-state aesthetic [unselected, selected]. Can be aes.Indexed (global) or aes.ByGroup wrapping aes.Indexed.\nNone"
  },
  {
    "objectID": "python/mode.Single.html#examples",
    "href": "python/mode.Single.html#examples",
    "title": "mode.Single",
    "section": "",
    "text": "&gt;&gt;&gt; from shinymap.mode import Single\n&gt;&gt;&gt; from shinymap import aes\n\n&gt;&gt;&gt; # Pre-select a region\n&gt;&gt;&gt; mode = Single(selected=\"region_a\")\n\n&gt;&gt;&gt; # Disable deselection (must always have one selected)\n&gt;&gt;&gt; mode = Single(allow_deselect=False)\n\n&gt;&gt;&gt; # Custom selection colors\n&gt;&gt;&gt; mode = Single(\n...     aes=aes.Indexed(\n...         fill_color=[\"#e5e7eb\", \"#3b82f6\"],  # gray -&gt; blue\n...     )\n... )"
  },
  {
    "objectID": "python/mode.Single.html#methods",
    "href": "python/mode.Single.html#methods",
    "title": "mode.Single",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nto_dict\nSerialize for JavaScript (snake_case, JS converts to camelCase).\n\n\n\n\n\nmode.Single.to_dict()\nSerialize for JavaScript (snake_case, JS converts to camelCase)."
  },
  {
    "objectID": "python/mode.Display.html",
    "href": "python/mode.Display.html",
    "title": "mode.Display",
    "section": "",
    "text": "mode.Display(aes=None, clickable=False, input_id=None)\nDisplay-only mode for output_map.\nRegions respond to hover but not click by default. Value determines which indexed aesthetic to use, enabling declarative value-to-color mapping.\nThis mode is specifically for output_map, allowing you to prepopulate the color scale in the UI declaration rather than computing it in the render function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\naes\nIndexedAesthetic | ByGroup | None\nIndexed aesthetic mapping values to colors. Can be aes.Indexed (global) or aes.ByGroup wrapping aes.Indexed. Index is computed as: min(value, len(list) - 1) (clamping).\nNone\n\n\nclickable\nbool\nIf True, clicking a region emits an input event with the region ID. Use with @reactive.event to trigger actions like showing modals. Default is False.\nFalse\n\n\ninput_id\nstr | None\nCustom input ID for click events. If None (default), uses “{output_map_id}_click”. Only used when clickable=True.\nNone\n\n\n\nExample:: from shinymap.mode import Display from shinymap import aes, output_map, render_map, Outline\noutline = Outline.from_dict({\n    \"question_1\": \"M 5 5 L 5 10 L 10 10 L 10 5 Z\",\n    \"question_2\": \"M 7 7 L 7 9 L 9 9 L 9 7 Z\"\n})\n\n# Traffic light colors for status values\n_ = output_map(\n    \"status_map\",\n    outline,\n    mode=Display(aes=aes.Indexed(\n        fill_color=[\"#f3f4f6\", \"#22c55e\", \"#f59e0b\", \"#ef4444\"]\n    ))\n)\n\n@render_map\ndef status_map():\n    # value 0=unknown, 1=good, 2=warning, 3=error\n    return Map(outline, value=status_values)\n\n# Clickable display map for triggering actions\n_ = output_map(\n    \"clickable_map\",\n    outline,\n    mode=Display(clickable=True)\n)\n\n@reactive.effect\n@reactive.event(input.clickable_map_click)\ndef show_region_modal():\n    region_id = input.clickable_map_click()\n    # Show modal with region details\n\n# Custom input ID\n_ = output_map(\n    \"my_map\",\n    outline,\n    mode=Display(clickable=True, input_id=\"region_clicked\")\n)\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_click_input_id\nGet the click input ID for this mode.\n\n\nto_dict\nSerialize for JavaScript (snake_case, JS converts to camelCase).\n\n\n\n\n\nmode.Display.get_click_input_id(output_id)\nGet the click input ID for this mode.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noutput_id\nstr\nThe output map’s ID\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr | None\nThe input ID for click events, or None if not clickable\n\n\n\n\n\n\n\nmode.Display.to_dict()\nSerialize for JavaScript (snake_case, JS converts to camelCase)."
  },
  {
    "objectID": "python/mode.Display.html#parameters",
    "href": "python/mode.Display.html#parameters",
    "title": "mode.Display",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\naes\nIndexedAesthetic | ByGroup | None\nIndexed aesthetic mapping values to colors. Can be aes.Indexed (global) or aes.ByGroup wrapping aes.Indexed. Index is computed as: min(value, len(list) - 1) (clamping).\nNone\n\n\nclickable\nbool\nIf True, clicking a region emits an input event with the region ID. Use with @reactive.event to trigger actions like showing modals. Default is False.\nFalse\n\n\ninput_id\nstr | None\nCustom input ID for click events. If None (default), uses “{output_map_id}_click”. Only used when clickable=True.\nNone\n\n\n\nExample:: from shinymap.mode import Display from shinymap import aes, output_map, render_map, Outline\noutline = Outline.from_dict({\n    \"question_1\": \"M 5 5 L 5 10 L 10 10 L 10 5 Z\",\n    \"question_2\": \"M 7 7 L 7 9 L 9 9 L 9 7 Z\"\n})\n\n# Traffic light colors for status values\n_ = output_map(\n    \"status_map\",\n    outline,\n    mode=Display(aes=aes.Indexed(\n        fill_color=[\"#f3f4f6\", \"#22c55e\", \"#f59e0b\", \"#ef4444\"]\n    ))\n)\n\n@render_map\ndef status_map():\n    # value 0=unknown, 1=good, 2=warning, 3=error\n    return Map(outline, value=status_values)\n\n# Clickable display map for triggering actions\n_ = output_map(\n    \"clickable_map\",\n    outline,\n    mode=Display(clickable=True)\n)\n\n@reactive.effect\n@reactive.event(input.clickable_map_click)\ndef show_region_modal():\n    region_id = input.clickable_map_click()\n    # Show modal with region details\n\n# Custom input ID\n_ = output_map(\n    \"my_map\",\n    outline,\n    mode=Display(clickable=True, input_id=\"region_clicked\")\n)"
  },
  {
    "objectID": "python/mode.Display.html#methods",
    "href": "python/mode.Display.html#methods",
    "title": "mode.Display",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_click_input_id\nGet the click input ID for this mode.\n\n\nto_dict\nSerialize for JavaScript (snake_case, JS converts to camelCase).\n\n\n\n\n\nmode.Display.get_click_input_id(output_id)\nGet the click input ID for this mode.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noutput_id\nstr\nThe output map’s ID\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr | None\nThe input ID for click events, or None if not clickable\n\n\n\n\n\n\n\nmode.Display.to_dict()\nSerialize for JavaScript (snake_case, JS converts to camelCase)."
  },
  {
    "objectID": "python/mode.Count.html",
    "href": "python/mode.Count.html",
    "title": "mode.Count",
    "section": "",
    "text": "mode.Count(values=None, max_count=None, aes=None)\nCount mode - unbounded counting.\nEach click increments the count. Use with aes.Indexed to define visual appearance based on count (with clamping for index lookup).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalues\ndict[str, int] | None\nInitial counts per region {id: count}. Default: all 0.\nNone\n\n\nmax_count\nint | None\nOptional cap for aesthetic indexing (clamping). If None, uses len(aes list) - 1 as the cap.\nNone\n\n\naes\nIndexedAesthetic | ByGroup | None\nIndexed aesthetic for visual feedback. Can be aes.Indexed (global) or aes.ByGroup wrapping aes.Indexed. Index is computed as: min(count, len(list) - 1) (clamping).\nNone\n\n\n\n\n\n\n&gt;&gt;&gt; from shinymap.mode import Count\n&gt;&gt;&gt; from shinymap import aes\n&gt;&gt;&gt; from shinymap.utils import linspace\n\n&gt;&gt;&gt; # Heat map with opacity gradient\n&gt;&gt;&gt; mode = Count(\n...     aes=aes.Indexed(\n...         fill_color=\"#f97316\",\n...         fill_opacity=linspace(0.0, 1.0, num=6),\n...     ),\n... )\n\n&gt;&gt;&gt; # Per-group palettes\n&gt;&gt;&gt; mode = Count(\n...     aes=aes.ByGroup(\n...         group_a=aes.Indexed(\n...             fill_color=\"#ef4444\", fill_opacity=linspace(0.2, 1.0, num=5)\n...         ),\n...         group_b=aes.Indexed(\n...             fill_color=\"#3b82f6\", fill_opacity=linspace(0.2, 1.0, num=5)\n...         ),\n...     ),\n... )\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_dict\nSerialize for JavaScript (snake_case, JS converts to camelCase).\n\n\n\n\n\nmode.Count.to_dict()\nSerialize for JavaScript (snake_case, JS converts to camelCase)."
  },
  {
    "objectID": "python/mode.Count.html#parameters",
    "href": "python/mode.Count.html#parameters",
    "title": "mode.Count",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nvalues\ndict[str, int] | None\nInitial counts per region {id: count}. Default: all 0.\nNone\n\n\nmax_count\nint | None\nOptional cap for aesthetic indexing (clamping). If None, uses len(aes list) - 1 as the cap.\nNone\n\n\naes\nIndexedAesthetic | ByGroup | None\nIndexed aesthetic for visual feedback. Can be aes.Indexed (global) or aes.ByGroup wrapping aes.Indexed. Index is computed as: min(count, len(list) - 1) (clamping).\nNone"
  },
  {
    "objectID": "python/mode.Count.html#examples",
    "href": "python/mode.Count.html#examples",
    "title": "mode.Count",
    "section": "",
    "text": "&gt;&gt;&gt; from shinymap.mode import Count\n&gt;&gt;&gt; from shinymap import aes\n&gt;&gt;&gt; from shinymap.utils import linspace\n\n&gt;&gt;&gt; # Heat map with opacity gradient\n&gt;&gt;&gt; mode = Count(\n...     aes=aes.Indexed(\n...         fill_color=\"#f97316\",\n...         fill_opacity=linspace(0.0, 1.0, num=6),\n...     ),\n... )\n\n&gt;&gt;&gt; # Per-group palettes\n&gt;&gt;&gt; mode = Count(\n...     aes=aes.ByGroup(\n...         group_a=aes.Indexed(\n...             fill_color=\"#ef4444\", fill_opacity=linspace(0.2, 1.0, num=5)\n...         ),\n...         group_b=aes.Indexed(\n...             fill_color=\"#3b82f6\", fill_opacity=linspace(0.2, 1.0, num=5)\n...         ),\n...     ),\n... )"
  },
  {
    "objectID": "python/mode.Count.html#methods",
    "href": "python/mode.Count.html#methods",
    "title": "mode.Count",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nto_dict\nSerialize for JavaScript (snake_case, JS converts to camelCase).\n\n\n\n\n\nmode.Count.to_dict()\nSerialize for JavaScript (snake_case, JS converts to camelCase)."
  },
  {
    "objectID": "python/index.html",
    "href": "python/index.html",
    "title": "Python API Reference",
    "section": "",
    "text": "Main UI components for creating interactive maps\n\n\n\ninput_map\n\n\n\noutput_map\n\n\n\nrender_map\n\n\n\nupdate_map\nUpdate an input_map or output_map without full re-render.\n\n\nMap\nCreate map from Outline object.\n\n\nOutline\nCanonical outline representation with polymorphic elements.\n\n\nWash\nCreate configured map functions with custom default aesthetics.\n\n\n\n\n\n\nMode classes controlling selection behavior\n\n\n\nmode.Single\nSingle selection mode with customization options.\n\n\nmode.Multiple\nMultiple selection mode with customization options.\n\n\nmode.Cycle\nCycle mode - finite state cycling (e.g., traffic light survey).\n\n\nmode.Count\nCount mode - unbounded counting.\n\n\nmode.Display\nDisplay-only mode for output_map.\n\n\n\n\n\n\nClasses for styling map regions\n\n\n\naes.Shape\nCreate shape aesthetic (fill and stroke).\n\n\naes.Line\nCreate line aesthetic (stroke only, no fill).\n\n\naes.ByState\nContainer for element aesthetics across interaction states.\n\n\naes.ByGroup\nContainer for aesthetics by group/region name.\n\n\naes.Indexed\nCreate indexed aesthetic for multi-state modes (Cycle, Count).\n\n\n\n\n\n\nFunctions for generating fill colors\n\n\n\naes.color.scale_sequential\nCreate a sequential color scale based on counts.\n\n\naes.color.scale_diverging\nCreate a diverging color scale (red-white-blue style).\n\n\naes.color.scale_qualitative\nCreate a qualitative color scale for categorical data.\n\n\n\n\n\n\nPARENT proxy for relative aesthetic values\n\n\n\nPARENT\n\n\n\nRelativeExpr\nA deferred expression that references a parent property.\n\n\nresolve_region\nResolve the final aesthetic for a region given its state.\n\n\npreview_region\nPreview the aesthetic resolution for a region with verbose output.\n\n\n\n\n\n\nTools for working with SVG geometry\n\n\n\noutline.Outline\nCanonical outline representation with polymorphic elements."
  },
  {
    "objectID": "python/index.html#core-components",
    "href": "python/index.html#core-components",
    "title": "Python API Reference",
    "section": "",
    "text": "Main UI components for creating interactive maps\n\n\n\ninput_map\n\n\n\noutput_map\n\n\n\nrender_map\n\n\n\nupdate_map\nUpdate an input_map or output_map without full re-render.\n\n\nMap\nCreate map from Outline object.\n\n\nOutline\nCanonical outline representation with polymorphic elements.\n\n\nWash\nCreate configured map functions with custom default aesthetics."
  },
  {
    "objectID": "python/index.html#selection-modes",
    "href": "python/index.html#selection-modes",
    "title": "Python API Reference",
    "section": "",
    "text": "Mode classes controlling selection behavior\n\n\n\nmode.Single\nSingle selection mode with customization options.\n\n\nmode.Multiple\nMultiple selection mode with customization options.\n\n\nmode.Cycle\nCycle mode - finite state cycling (e.g., traffic light survey).\n\n\nmode.Count\nCount mode - unbounded counting.\n\n\nmode.Display\nDisplay-only mode for output_map."
  },
  {
    "objectID": "python/index.html#aesthetics",
    "href": "python/index.html#aesthetics",
    "title": "Python API Reference",
    "section": "",
    "text": "Classes for styling map regions\n\n\n\naes.Shape\nCreate shape aesthetic (fill and stroke).\n\n\naes.Line\nCreate line aesthetic (stroke only, no fill).\n\n\naes.ByState\nContainer for element aesthetics across interaction states.\n\n\naes.ByGroup\nContainer for aesthetics by group/region name.\n\n\naes.Indexed\nCreate indexed aesthetic for multi-state modes (Cycle, Count)."
  },
  {
    "objectID": "python/index.html#color-scales",
    "href": "python/index.html#color-scales",
    "title": "Python API Reference",
    "section": "",
    "text": "Functions for generating fill colors\n\n\n\naes.color.scale_sequential\nCreate a sequential color scale based on counts.\n\n\naes.color.scale_diverging\nCreate a diverging color scale (red-white-blue style).\n\n\naes.color.scale_qualitative\nCreate a qualitative color scale for categorical data."
  },
  {
    "objectID": "python/index.html#relative-expressions",
    "href": "python/index.html#relative-expressions",
    "title": "Python API Reference",
    "section": "",
    "text": "PARENT proxy for relative aesthetic values\n\n\n\nPARENT\n\n\n\nRelativeExpr\nA deferred expression that references a parent property.\n\n\nresolve_region\nResolve the final aesthetic for a region given its state.\n\n\npreview_region\nPreview the aesthetic resolution for a region with verbose output."
  },
  {
    "objectID": "python/index.html#outline-utilities",
    "href": "python/index.html#outline-utilities",
    "title": "Python API Reference",
    "section": "",
    "text": "Tools for working with SVG geometry\n\n\n\noutline.Outline\nCanonical outline representation with polymorphic elements."
  },
  {
    "objectID": "python/aes.color.scale_qualitative.html",
    "href": "python/aes.color.scale_qualitative.html",
    "title": "aes.color.scale_qualitative",
    "section": "",
    "text": "aes.color.scale_qualitative(\n    categories,\n    region_ids,\n    palette=QUALITATIVE,\n    neutral_color=NEUTRALS['fill'],\n)\nCreate a qualitative color scale for categorical data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncategories\nMapping[str, str | None]\nMapping of region_id to category name (or None)\nrequired\n\n\nregion_ids\nlist[str]\nAll region IDs to include\nrequired\n\n\npalette\nlist[str]\nColor palette to use (cycles if more categories than colors)\nQUALITATIVE\n\n\nneutral_color\nstr\nColor for regions with no category\nNEUTRALS['fill']\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, str]\nMapping of region_id to hex color"
  },
  {
    "objectID": "python/aes.color.scale_qualitative.html#parameters",
    "href": "python/aes.color.scale_qualitative.html#parameters",
    "title": "aes.color.scale_qualitative",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ncategories\nMapping[str, str | None]\nMapping of region_id to category name (or None)\nrequired\n\n\nregion_ids\nlist[str]\nAll region IDs to include\nrequired\n\n\npalette\nlist[str]\nColor palette to use (cycles if more categories than colors)\nQUALITATIVE\n\n\nneutral_color\nstr\nColor for regions with no category\nNEUTRALS['fill']"
  },
  {
    "objectID": "python/aes.color.scale_qualitative.html#returns",
    "href": "python/aes.color.scale_qualitative.html#returns",
    "title": "aes.color.scale_qualitative",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\ndict[str, str]\nMapping of region_id to hex color"
  },
  {
    "objectID": "python/aes.Shape.html",
    "href": "python/aes.Shape.html",
    "title": "aes.Shape",
    "section": "",
    "text": "aes.Shape(\n    fill_color=MISSING,\n    fill_opacity=MISSING,\n    stroke_color=MISSING,\n    stroke_width=MISSING,\n    stroke_dasharray=MISSING,\n    non_scaling_stroke=MISSING,\n)\nCreate shape aesthetic (fill and stroke).\nUse for filled shapes like circles, rectangles, paths, polygons.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfill_color\nstr | None | MissingType\nFill color (e.g., “#3b82f6”). None means “none” (transparent).\nMISSING\n\n\nfill_opacity\nfloat | RelativeExpr | None | MissingType\nFill opacity (0.0 to 1.0), or RelativeExpr for parent-relative\nMISSING\n\n\nstroke_color\nstr | None | MissingType\nStroke color (e.g., “#000”). None means “none”.\nMISSING\n\n\nstroke_width\nfloat | RelativeExpr | None | MissingType\nStroke width in viewBox units, or RelativeExpr for parent-relative values\nMISSING\n\n\nstroke_dasharray\nstr | None | MissingType\nDash pattern (e.g., “5,5”). Use linestyle constants.\nMISSING\n\n\nnon_scaling_stroke\nbool | MissingType\nIf True, stroke width is in screen pixels (default: False)\nMISSING\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nShapeAesthetic\nShapeAesthetic instance\n\n\n\n\n\n\n&gt;&gt;&gt; from shinymap import aes\n&gt;&gt;&gt; region_aes = aes.Shape(fill_color=\"#3b82f6\", stroke_color=\"#000\", stroke_width=1)"
  },
  {
    "objectID": "python/aes.Shape.html#parameters",
    "href": "python/aes.Shape.html#parameters",
    "title": "aes.Shape",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nfill_color\nstr | None | MissingType\nFill color (e.g., “#3b82f6”). None means “none” (transparent).\nMISSING\n\n\nfill_opacity\nfloat | RelativeExpr | None | MissingType\nFill opacity (0.0 to 1.0), or RelativeExpr for parent-relative\nMISSING\n\n\nstroke_color\nstr | None | MissingType\nStroke color (e.g., “#000”). None means “none”.\nMISSING\n\n\nstroke_width\nfloat | RelativeExpr | None | MissingType\nStroke width in viewBox units, or RelativeExpr for parent-relative values\nMISSING\n\n\nstroke_dasharray\nstr | None | MissingType\nDash pattern (e.g., “5,5”). Use linestyle constants.\nMISSING\n\n\nnon_scaling_stroke\nbool | MissingType\nIf True, stroke width is in screen pixels (default: False)\nMISSING"
  },
  {
    "objectID": "python/aes.Shape.html#returns",
    "href": "python/aes.Shape.html#returns",
    "title": "aes.Shape",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nShapeAesthetic\nShapeAesthetic instance"
  },
  {
    "objectID": "python/aes.Shape.html#examples",
    "href": "python/aes.Shape.html#examples",
    "title": "aes.Shape",
    "section": "",
    "text": "&gt;&gt;&gt; from shinymap import aes\n&gt;&gt;&gt; region_aes = aes.Shape(fill_color=\"#3b82f6\", stroke_color=\"#000\", stroke_width=1)"
  },
  {
    "objectID": "python/aes.Indexed.html",
    "href": "python/aes.Indexed.html",
    "title": "aes.Indexed",
    "section": "",
    "text": "aes.Indexed(\n    fill_color=None,\n    fill_opacity=None,\n    stroke_color=None,\n    stroke_width=None,\n    stroke_dasharray=None,\n)\nCreate indexed aesthetic for multi-state modes (Cycle, Count).\nEach property can be a single value (applied to all states) or a list of values indexed by state: - For Single/Multiple: index 0 = off, index 1 = on - For Cycle mode: index = count % n (wrapping) - For Count mode: index = min(count, len(list) - 1) (clamping)\nIMPORTANT: Index 0 is used as the base aesthetic for ALL regions. This ensures never-touched regions and count=0 regions look the same.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfill_color\nstr | list[str] | None\nSingle color or list of colors indexed by state.\nNone\n\n\nfill_opacity\nfloat | list[float] | None\nSingle value or list of opacities (0.0-1.0).\nNone\n\n\nstroke_color\nstr | list[str] | None\nOptional stroke color(s).\nNone\n\n\nstroke_width\nfloat | list[float] | None\nOptional stroke width(s).\nNone\n\n\nstroke_dasharray\nstr | list[str] | None\nOptional dash pattern(s) for line styling.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIndexedAesthetic\nIndexedAesthetic instance\n\n\n\n\n\n\n&gt;&gt;&gt; from shinymap import aes\n\n&gt;&gt;&gt; # Two-state (off/on) with different colors\n&gt;&gt;&gt; _ = aes.Indexed(fill_color=[\"#e5e7eb\", \"#3b82f6\"])\n\n&gt;&gt;&gt; # Heat map with opacity gradient\n&gt;&gt;&gt; from shinymap.utils import linspace\n&gt;&gt;&gt; _ = aes.Indexed(fill_color=\"#f97316\", fill_opacity=linspace(0.0, 1.0, num=6))\n\n&gt;&gt;&gt; # Traffic light (4 states)\n&gt;&gt;&gt; _ = aes.Indexed(fill_color=[\"#e2e8f0\", \"#ef4444\", \"#eab308\", \"#22c55e\"])"
  },
  {
    "objectID": "python/aes.Indexed.html#parameters",
    "href": "python/aes.Indexed.html#parameters",
    "title": "aes.Indexed",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nfill_color\nstr | list[str] | None\nSingle color or list of colors indexed by state.\nNone\n\n\nfill_opacity\nfloat | list[float] | None\nSingle value or list of opacities (0.0-1.0).\nNone\n\n\nstroke_color\nstr | list[str] | None\nOptional stroke color(s).\nNone\n\n\nstroke_width\nfloat | list[float] | None\nOptional stroke width(s).\nNone\n\n\nstroke_dasharray\nstr | list[str] | None\nOptional dash pattern(s) for line styling.\nNone"
  },
  {
    "objectID": "python/aes.Indexed.html#returns",
    "href": "python/aes.Indexed.html#returns",
    "title": "aes.Indexed",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nIndexedAesthetic\nIndexedAesthetic instance"
  },
  {
    "objectID": "python/aes.Indexed.html#examples",
    "href": "python/aes.Indexed.html#examples",
    "title": "aes.Indexed",
    "section": "",
    "text": "&gt;&gt;&gt; from shinymap import aes\n\n&gt;&gt;&gt; # Two-state (off/on) with different colors\n&gt;&gt;&gt; _ = aes.Indexed(fill_color=[\"#e5e7eb\", \"#3b82f6\"])\n\n&gt;&gt;&gt; # Heat map with opacity gradient\n&gt;&gt;&gt; from shinymap.utils import linspace\n&gt;&gt;&gt; _ = aes.Indexed(fill_color=\"#f97316\", fill_opacity=linspace(0.0, 1.0, num=6))\n\n&gt;&gt;&gt; # Traffic light (4 states)\n&gt;&gt;&gt; _ = aes.Indexed(fill_color=[\"#e2e8f0\", \"#ef4444\", \"#eab308\", \"#22c55e\"])"
  },
  {
    "objectID": "python/aes.ByGroup.html",
    "href": "python/aes.ByGroup.html",
    "title": "aes.ByGroup",
    "section": "",
    "text": "aes.ByGroup(**groups)\nContainer for aesthetics by group/region name.\nUsed by input_map() and output_map() for group-wise configuration. ByGroup wraps ByState (row-first composition).\n\n\n__all: Default for all regions regardless of type (lowest priority) __shape: Default for shape elements (medium priority) __line: Default for line elements (medium priority) __text: Default for text elements (medium priority) : Named groups from geometry metadata (high priority) : Individual region IDs (highest priority)\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**groups\nByState | BaseAesthetic | None | MissingType\nMapping of group names to aesthetics. Values can be ByState for full state config, or single aesthetic for base only.\n{}\n\n\n\n\n\n\n&gt;&gt;&gt; from shinymap import aes, PARENT\n\n&gt;&gt;&gt; _ = aes.ByGroup(\n...     __all=aes.ByState(\n...         base=aes.Shape(fill_color=\"#e5e7eb\"),\n...         hover=aes.Shape(stroke_width=PARENT.stroke_width + 1),\n...     ),\n...     coastal=aes.Shape(fill_color=\"#3b82f6\"),  # base only shorthand\n...     mountain=aes.ByState(\n...         base=aes.Shape(fill_color=\"#10b981\"),\n...         select=aes.Shape(fill_color=\"#6ee7b7\"),\n...     ),\n... )\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_dict\nConvert dict to ByGroup.\n\n\nto_dict\nConvert to dict with type key, recursively converting nested aesthetics.\n\n\n\n\n\naes.ByGroup.from_dict(d)\nConvert dict to ByGroup.\nValues can be ByState dicts or leaf aesthetic dicts.\n\n\n\naes.ByGroup.to_dict()\nConvert to dict with type key, recursively converting nested aesthetics."
  },
  {
    "objectID": "python/aes.ByGroup.html#special-group-names",
    "href": "python/aes.ByGroup.html#special-group-names",
    "title": "aes.ByGroup",
    "section": "",
    "text": "__all: Default for all regions regardless of type (lowest priority) __shape: Default for shape elements (medium priority) __line: Default for line elements (medium priority) __text: Default for text elements (medium priority) : Named groups from geometry metadata (high priority) : Individual region IDs (highest priority)"
  },
  {
    "objectID": "python/aes.ByGroup.html#parameters",
    "href": "python/aes.ByGroup.html#parameters",
    "title": "aes.ByGroup",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\n**groups\nByState | BaseAesthetic | None | MissingType\nMapping of group names to aesthetics. Values can be ByState for full state config, or single aesthetic for base only.\n{}"
  },
  {
    "objectID": "python/aes.ByGroup.html#examples",
    "href": "python/aes.ByGroup.html#examples",
    "title": "aes.ByGroup",
    "section": "",
    "text": "&gt;&gt;&gt; from shinymap import aes, PARENT\n\n&gt;&gt;&gt; _ = aes.ByGroup(\n...     __all=aes.ByState(\n...         base=aes.Shape(fill_color=\"#e5e7eb\"),\n...         hover=aes.Shape(stroke_width=PARENT.stroke_width + 1),\n...     ),\n...     coastal=aes.Shape(fill_color=\"#3b82f6\"),  # base only shorthand\n...     mountain=aes.ByState(\n...         base=aes.Shape(fill_color=\"#10b981\"),\n...         select=aes.Shape(fill_color=\"#6ee7b7\"),\n...     ),\n... )"
  },
  {
    "objectID": "python/aes.ByGroup.html#methods",
    "href": "python/aes.ByGroup.html#methods",
    "title": "aes.ByGroup",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfrom_dict\nConvert dict to ByGroup.\n\n\nto_dict\nConvert to dict with type key, recursively converting nested aesthetics.\n\n\n\n\n\naes.ByGroup.from_dict(d)\nConvert dict to ByGroup.\nValues can be ByState dicts or leaf aesthetic dicts.\n\n\n\naes.ByGroup.to_dict()\nConvert to dict with type key, recursively converting nested aesthetics."
  },
  {
    "objectID": "python/RelativeExpr.html",
    "href": "python/RelativeExpr.html",
    "title": "RelativeExpr",
    "section": "",
    "text": "RelativeExpr(property, operator, operand)\nA deferred expression that references a parent property.\nThese expressions capture the intent to compute a value relative to a parent property. The library resolves them automatically during rendering when the parent context is available.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nproperty\nstr\nThe parent property name (e.g., “stroke_width”)\n\n\noperator\nLiteral['+', '-', '*', '/']\nThe mathematical operator (+, -, *, /)\n\n\noperand\nfloat\nThe numeric value to apply with the operator\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nresolve\nResolve this expression given the parent’s actual value.\n\n\nto_json\nSerialize for sending to JavaScript.\n\n\n\n\n\nRelativeExpr.resolve(parent_value)\nResolve this expression given the parent’s actual value.\nThis method is called by the library’s resolution layer. You typically don’t need to call this directly.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nparent_value\nfloat\nThe parent’s value for this property\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nThe computed value\n\n\n\n\n\n\n&gt;&gt;&gt; expr = PARENT.stroke_width + 2\n&gt;&gt;&gt; expr.resolve(1.0)  # 1.0 + 2 = 3.0\n3.0\n\n\n\n\nRelativeExpr.to_json()\nSerialize for sending to JavaScript.\nReturns a dict with a marker that JavaScript can detect and resolve at render time."
  },
  {
    "objectID": "python/RelativeExpr.html#attributes",
    "href": "python/RelativeExpr.html#attributes",
    "title": "RelativeExpr",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nproperty\nstr\nThe parent property name (e.g., “stroke_width”)\n\n\noperator\nLiteral['+', '-', '*', '/']\nThe mathematical operator (+, -, *, /)\n\n\noperand\nfloat\nThe numeric value to apply with the operator"
  },
  {
    "objectID": "python/RelativeExpr.html#methods",
    "href": "python/RelativeExpr.html#methods",
    "title": "RelativeExpr",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nresolve\nResolve this expression given the parent’s actual value.\n\n\nto_json\nSerialize for sending to JavaScript.\n\n\n\n\n\nRelativeExpr.resolve(parent_value)\nResolve this expression given the parent’s actual value.\nThis method is called by the library’s resolution layer. You typically don’t need to call this directly.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nparent_value\nfloat\nThe parent’s value for this property\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nThe computed value\n\n\n\n\n\n\n&gt;&gt;&gt; expr = PARENT.stroke_width + 2\n&gt;&gt;&gt; expr.resolve(1.0)  # 1.0 + 2 = 3.0\n3.0\n\n\n\n\nRelativeExpr.to_json()\nSerialize for sending to JavaScript.\nReturns a dict with a marker that JavaScript can detect and resolve at render time."
  },
  {
    "objectID": "python/Outline.html",
    "href": "python/Outline.html",
    "title": "Outline",
    "section": "",
    "text": "Outline(regions, metadata=dict())\nCanonical outline representation with polymorphic elements.\nThis class encapsulates SVG outline with metadata. It supports both: - v0.x format: String-based paths (for backward compatibility) - v1.x format: Polymorphic element objects (Circle, Rect, Path, etc.)\nThe class automatically converts between formats for seamless migration.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nregions\nRegions\nRegions object (dict subclass) mapping region IDs to lists of elements (str for v0.x compatibility, Element objects for v1.x)\n\n\nmetadata\ndict[str, Any]\nOptional metadata dict (viewBox, overlays, source, license, etc.)\n\n\n\n\n\n\nSVG elements preserve aesthetic attributes (fill, stroke, etc.) but these are NOT used by shinymap for rendering. Interactive appearance is controlled via Python API. Preserved values are for SVG export and reference only.\n\n\n\n&gt;&gt;&gt; # v0.x format (backward compatible)\n&gt;&gt;&gt; data = {\"region1\": [\"M 0 0 L 10 0\"], \"_metadata\": {\"viewBox\": \"0 0 100 100\"}}\n&gt;&gt;&gt; geo = Outline.from_dict(data)\n\n&gt;&gt;&gt; # v1.x format (polymorphic elements)\n&gt;&gt;&gt; from shinymap.outline import Circle\n&gt;&gt;&gt; geo = Outline(regions={\"r1\": [Circle(cx=100, cy=100, r=50)]}, metadata={})\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_dict\nLoad outline from dict (supports v0.x strings and v1.x element dicts).\n\n\nfrom_json\nLoad outline from JSON file.\n\n\nfrom_svg\nExtract outline from SVG file (all element types).\n\n\ngroups\nGet group membership from metadata.\n\n\nhidden\nGet hidden region IDs from metadata.\n\n\nlayers_dict\nGet layers configuration dict for JavaScript props.\n\n\nmain_regions\nGet main regions (excluding overlays).\n\n\nmerge_layers\nMerge provided layers with outline’s metadata overlays.\n\n\nmetadata_dict\nBuild outline metadata dict for JavaScript props.\n\n\noverlay_regions\nGet overlay regions only.\n\n\noverlays\nGet overlay region IDs from metadata.\n\n\npath_as_line\nMark regions as lines described in path notation.\n\n\nregion_types\nGet aesthetic element type for each region.\n\n\nrelabel\nRename or merge regions (returns new Outline object).\n\n\nset_overlays\nSet overlay region IDs in metadata (returns new Outline object).\n\n\nto_dict\nExport to dict in shinymap JSON format.\n\n\nto_json\nWrite outline to JSON file.\n\n\nunderlays\nGet underlay region IDs from metadata.\n\n\nupdate_metadata\nUpdate metadata (returns new Outline object).\n\n\nviewbox\nGet viewBox from metadata, or compute from outline coordinates.\n\n\n\n\n\nOutline.from_dict(data)\nLoad outline from dict (supports v0.x strings and v1.x element dicts).\nAutomatically detects format and converts: - v0.x: String paths → kept as strings (backward compatible) - v1.x: Element dicts → deserialized to Element objects\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\ndict[str, Any]\nDictionary with regions and optional _metadata key\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nOutline object with normalized list-based regions\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf _metadata exists but is not a dict\n\n\n\n\n\n\n&gt;&gt;&gt; # v0.x string format (backward compatible)\n&gt;&gt;&gt; outline = Outline.from_dict({\"a\": \"M 0 0 L 10 0\"})\n&gt;&gt;&gt; list(outline.regions.keys())\n['a']\n\n&gt;&gt;&gt; # v0.x list format\n&gt;&gt;&gt; outline = Outline.from_dict({\"a\": [\"M 0 0\", \"L 10 0\"]})\n&gt;&gt;&gt; outline.regions[\"a\"]\n['M 0 0', 'L 10 0']\n\n&gt;&gt;&gt; # v1.x element format\n&gt;&gt;&gt; data = {\"a\": [{\"type\": \"circle\", \"cx\": 100, \"cy\": 100, \"r\": 50}]}\n&gt;&gt;&gt; outline = Outline.from_dict(data)\n&gt;&gt;&gt; outline.regions[\"a\"]\n[Circle(cx=100, cy=100, r=50)]\n\n\n\n\nOutline.from_json(json_path)\nLoad outline from JSON file.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\njson_path\nstr | PathType\nPath to JSON file in shinymap format\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nOutline object with normalized list-based paths\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_json(\"japan_prefectures.json\")  # doctest: +SKIP\n&gt;&gt;&gt; geo.regions.keys()  # doctest: +SKIP\ndict_keys(['01', '02', ...])\n\n\n\n\nOutline.from_svg(svg_path, extract_viewbox=True)\nExtract outline from SVG file (all element types).\nExtracts all supported SVG shape elements (path, circle, rect, polygon, ellipse, line, text) and generates auto-IDs for elements without IDs. This is v1.0 behavior - returns polymorphic Element objects instead of path strings.\nPreserves SVG aesthetics (fill, stroke, etc.) but these are NOT used by shinymap for rendering. See class docstring for details.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsvg_path\nstr | PathType\nPath to input SVG file\nrequired\n\n\nextract_viewbox\nbool\nIf True, extract viewBox from SVG root element\nTrue\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nOutline object with extracted elements (v1.x format)\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nFileNotFoundError\nIf svg_path does not exist\n\n\n\nValueError\nIf SVG parsing fails\n\n\n\n\n\n\n&gt;&gt;&gt; # Basic extraction (all element types)\n&gt;&gt;&gt; geo = Outline.from_svg(\"design.svg\")  # doctest: +SKIP\n&gt;&gt;&gt; geo.regions.keys()  # doctest: +SKIP\ndict_keys(['circle_1', 'rect_1', 'path_1', 'text_1'])\n\n&gt;&gt;&gt; # With transformations\n&gt;&gt;&gt; geo = Outline.from_svg(\"map.svg\")  # doctest: +SKIP\n&gt;&gt;&gt; geo.relabel({\"hokkaido\": [\"circle_1\", \"circle_2\"]})  # doctest: +SKIP\n&gt;&gt;&gt; geo.set_overlays([\"_border\"])  # doctest: +SKIP\n&gt;&gt;&gt; geo.to_json(\"output.json\")  # doctest: +SKIP\n\n\n\n\nOutline.groups()\nGet group membership from metadata.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, list[str]]\nDict mapping group names to lists of region IDs\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region1\": [\"M 0 0\"],\n...     \"region2\": [\"M 10 0\"],\n...     \"_metadata\": {\"groups\": {\"coastal\": [\"region1\", \"region2\"]}}\n... })\n&gt;&gt;&gt; geo.groups()\n{'coastal': ['region1', 'region2']}\n\n\n\n\nOutline.hidden()\nGet hidden region IDs from metadata.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist[str]\nList of region IDs marked as hidden\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_temp\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"hidden\": [\"_temp\"]}\n... })\n&gt;&gt;&gt; geo.hidden()\n['_temp']\n\n\n\n\nOutline.layers_dict()\nGet layers configuration dict for JavaScript props.\nReturns a dict with overlays, underlays, and hidden keys if any layer configuration is present in metadata. Returns None if no layer configuration exists.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, list[str]] | None\nDict with layer configuration or None\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"], \"underlays\": [\"_bg\"]}\n... })\n&gt;&gt;&gt; geo.layers_dict()\n{'overlays': ['_border'], 'underlays': ['_bg']}\n\n\n\n\nOutline.main_regions()\nGet main regions (excluding overlays).\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRegions\nRegions object with main regions {regionId: [element1, …]}\n\n\n\nRegions\n(elements can be strings for v0.x or Element objects for v1.x)\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"]}\n... })\n&gt;&gt;&gt; geo.main_regions()\nRegions({\n  'region': ['M 0 0'],\n})\n\n\n\n\nOutline.merge_layers(layers)\nMerge provided layers with outline’s metadata overlays.\nReturns a new Outline with updated metadata containing the merged layers configuration. Explicit layers take priority over metadata overlays.\nThis method follows the immutable pattern - the original Outline is unchanged and a new Outline is returned.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlayers\ndict[str, list[str]] | None\nOptional explicit layer configuration with keys: underlays, overlays, hidden\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline with merged layers in metadata\n\n\n\n\n\n\n&gt;&gt;&gt; outline = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"]}\n... })\n&gt;&gt;&gt; merged = outline.merge_layers({\"underlays\": [\"_bg\"]})\n&gt;&gt;&gt; merged.metadata\n{'overlays': ['_border'], 'underlays': ['_bg']}\n&gt;&gt;&gt; merged = outline.merge_layers({\"overlays\": [\"_custom\"]})\n&gt;&gt;&gt; merged.metadata\n{'overlays': ['_custom']}\n\n\n\n\nOutline.metadata_dict(view_box=None)\nBuild outline metadata dict for JavaScript props.\nCreates the outlineMetadata object sent to React components, containing viewBox and groups information.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nview_box\ntuple[float, float, float, float] | None\nOptional override viewBox tuple. If None, uses self.viewbox()\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, Any] | None\nDict with viewBox and groups, or None if no metadata\n\n\n\n\n\n\n&gt;&gt;&gt; outline = Outline.from_dict({\n...     \"region1\": [\"M 0 0 L 100 100\"],\n...     \"_metadata\": {\"groups\": {\"coastal\": [\"region1\"]}}\n... })\n&gt;&gt;&gt; outline.metadata_dict()\n{'viewBox': '-2.0 -2.0 104.0 104.0', 'groups': {'coastal': ['region1']}}\n\n\n\n\nOutline.overlay_regions()\nGet overlay regions only.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRegions\nRegions object with overlay regions {regionId: [element1, …]}\n\n\n\nRegions\n(elements can be strings for v0.x or Element objects for v1.x)\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"]}\n... })\n&gt;&gt;&gt; geo.overlay_regions()\nRegions({\n  '_border': ['M 0 0 L 100 0'],\n})\n\n\n\n\nOutline.overlays()\nGet overlay region IDs from metadata.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist[str]\nList of region IDs marked as overlays\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"]}\n... })\n&gt;&gt;&gt; geo.overlays()\n['_border']\n\n\n\n\nOutline.path_as_line(*region_ids)\nMark regions as lines described in path notation.\nSome SVG paths represent lines (dividers, borders, grids) rather than filled shapes. This method stores the region IDs so that stroke-only aesthetics are automatically applied.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n*region_ids\nstr\nRegion IDs containing line elements in path notation\n()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline object with line regions recorded in metadata\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0 L 100 100\"],\n...     \"_divider\": [\"M 50 0 L 50 100\"]\n... })\n&gt;&gt;&gt; geo2 = geo.path_as_line(\"_divider\")\n&gt;&gt;&gt; # Now _divider will use stroke-only rendering\n\n\n\n\nOutline.region_types()\nGet aesthetic element type for each region.\nReturns a mapping of region_id -&gt; element_type where element_type is one of “shape”, “line”, or “text” for aesthetic resolution purposes.\nPriority: 1. metadata[“lines_as_path”] - explicit line override for path elements 2. Element’s element_name: - “line” → “line” - “text” → “text” - All others → “shape”\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, str]\nDict mapping region IDs to their aesthetic element types\n\n\n\n\n\n\n&gt;&gt;&gt; # v1.x format with mixed elements\n&gt;&gt;&gt; from shinymap.outline import Circle, Line, Text, Path\n&gt;&gt;&gt; outline = Outline(regions={\n...     \"region\": [Circle(cx=50, cy=50, r=30)],\n...     \"_divider\": [Line(x1=0, y1=50, x2=100, y2=50)],\n...     \"label\": [Text(x=50, y=50, text=\"A\")],\n... }, metadata={})\n&gt;&gt;&gt; outline.region_types()\n{'region': 'shape', '_divider': 'line', 'label': 'text'}\n\n&gt;&gt;&gt; # Path marked as line via path_as_line()\n&gt;&gt;&gt; outline = Outline(regions={\n...     \"_border\": [Path(d=\"M 0 0 L 100 0\")],\n... }, metadata={}).path_as_line(\"_border\")\n&gt;&gt;&gt; outline.region_types()\n{'_border': 'line'}\n\n\n\n\nOutline.relabel(mapping)\nRename or merge regions (returns new Outline object).\nThis method applies relabeling transformations to create a new Outline object with renamed or merged regions. Original object is unchanged.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmapping\ndict[str, str | list[str]]\nDict mapping new IDs to old ID(s) - String value: rename single region (e.g., {“tokyo”: “path_5”}) - List value: merge multiple regions (e.g., {“hokkaido”: [“path_1”, “path_2”]})\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline object with relabeled regions\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf an old ID in mapping doesn’t exist\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"path_1\": [\"M 0 0 L 10 0\"],\n...     \"path_2\": [\"M 20 0 L 30 0\"],\n...     \"path_3\": [\"M 40 0 L 50 0\"]\n... })\n&gt;&gt;&gt; # Rename and merge\n&gt;&gt;&gt; geo2 = geo.relabel({\n...     \"region_a\": [\"path_1\", \"path_2\"],  # Merge\n...     \"_border\": \"path_3\"                 # Rename\n... })\n&gt;&gt;&gt; geo2.regions.keys()\ndict_keys(['region_a', '_border'])\n\n\n\n\nOutline.set_overlays(overlay_ids)\nSet overlay region IDs in metadata (returns new Outline object).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noverlay_ids\nlist[str]\nList of region IDs to mark as overlays\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline object with updated overlay metadata\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"]\n... })\n&gt;&gt;&gt; geo2 = geo.set_overlays([\"_border\"])\n&gt;&gt;&gt; geo2.overlays()\n['_border']\n\n\n\n\nOutline.to_dict()\nExport to dict in shinymap JSON format.\nAutomatically serializes elements: - v0.x format: Strings are kept as-is - v1.x format: Element objects are serialized to dicts via to_dict()\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, Any]\nDict with _metadata and region data (v0.x strings or v1.x element dicts)\n\n\n\n\n\n\n&gt;&gt;&gt; # v0.x format (strings) - empty metadata is omitted\n&gt;&gt;&gt; outline = Outline.from_dict({\"region\": [\"M 0 0\"]})\n&gt;&gt;&gt; outline.to_dict()\n{'region': ['M 0 0']}\n\n&gt;&gt;&gt; # v1.x format (elements)\n&gt;&gt;&gt; from shinymap.outline import Circle\n&gt;&gt;&gt; outline = Outline(regions={\"r1\": [Circle(cx=100, cy=100, r=50)]}, metadata={})\n&gt;&gt;&gt; outline.to_dict()\n{'r1': [{'type': 'circle', 'cx': 100, 'cy': 100, 'r': 50}]}\n\n\n\n\nOutline.to_json(output_path)\nWrite outline to JSON file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noutput_path\nstr | PathType\nPath to write JSON file\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_svg(\"map.svg\")  # doctest: +SKIP\n&gt;&gt;&gt; geo.to_json(\"output.json\")  # doctest: +SKIP\n\n\n\n\nOutline.underlays()\nGet underlay region IDs from metadata.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist[str]\nList of region IDs marked as underlays\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_bg\": [\"M 0 0 L 100 0 L 100 100 L 0 100 Z\"],\n...     \"_metadata\": {\"underlays\": [\"_bg\"]}\n... })\n&gt;&gt;&gt; geo.underlays()\n['_bg']\n\n\n\n\nOutline.update_metadata(metadata)\nUpdate metadata (returns new Outline object).\nMerges provided metadata with existing metadata. Existing keys are overwritten by new values.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetadata\ndict[str, Any]\nDict of metadata to merge\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline object with updated metadata\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\"region\": [\"M 0 0\"]})\n&gt;&gt;&gt; geo2 = geo.update_metadata({\n...     \"source\": \"Wikimedia Commons\",\n...     \"license\": \"CC BY-SA 3.0\"\n... })\n&gt;&gt;&gt; geo2.metadata[\"source\"]\n'Wikimedia Commons'\n\n\n\n\nOutline.viewbox(padding=0.02)\nGet viewBox from metadata, or compute from outline coordinates.\nWorks with both v0.x (string paths) and v1.x (Element objects).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npadding\nfloat\nPadding fraction for computed viewBox (default 2%)\n0.02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ntuple[float, float, float, float]\nViewBox tuple in format (x, y, width, height)\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\"a\": [\"M 0 0 L 100 100\"]})\n&gt;&gt;&gt; geo.viewbox()  # Returns with 2% padding\n(-2.0, -2.0, 104.0, 104.0)"
  },
  {
    "objectID": "python/Outline.html#attributes",
    "href": "python/Outline.html#attributes",
    "title": "Outline",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nregions\nRegions\nRegions object (dict subclass) mapping region IDs to lists of elements (str for v0.x compatibility, Element objects for v1.x)\n\n\nmetadata\ndict[str, Any]\nOptional metadata dict (viewBox, overlays, source, license, etc.)"
  },
  {
    "objectID": "python/Outline.html#note-on-aesthetics",
    "href": "python/Outline.html#note-on-aesthetics",
    "title": "Outline",
    "section": "",
    "text": "SVG elements preserve aesthetic attributes (fill, stroke, etc.) but these are NOT used by shinymap for rendering. Interactive appearance is controlled via Python API. Preserved values are for SVG export and reference only."
  },
  {
    "objectID": "python/Outline.html#examples",
    "href": "python/Outline.html#examples",
    "title": "Outline",
    "section": "",
    "text": "&gt;&gt;&gt; # v0.x format (backward compatible)\n&gt;&gt;&gt; data = {\"region1\": [\"M 0 0 L 10 0\"], \"_metadata\": {\"viewBox\": \"0 0 100 100\"}}\n&gt;&gt;&gt; geo = Outline.from_dict(data)\n\n&gt;&gt;&gt; # v1.x format (polymorphic elements)\n&gt;&gt;&gt; from shinymap.outline import Circle\n&gt;&gt;&gt; geo = Outline(regions={\"r1\": [Circle(cx=100, cy=100, r=50)]}, metadata={})"
  },
  {
    "objectID": "python/Outline.html#methods",
    "href": "python/Outline.html#methods",
    "title": "Outline",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfrom_dict\nLoad outline from dict (supports v0.x strings and v1.x element dicts).\n\n\nfrom_json\nLoad outline from JSON file.\n\n\nfrom_svg\nExtract outline from SVG file (all element types).\n\n\ngroups\nGet group membership from metadata.\n\n\nhidden\nGet hidden region IDs from metadata.\n\n\nlayers_dict\nGet layers configuration dict for JavaScript props.\n\n\nmain_regions\nGet main regions (excluding overlays).\n\n\nmerge_layers\nMerge provided layers with outline’s metadata overlays.\n\n\nmetadata_dict\nBuild outline metadata dict for JavaScript props.\n\n\noverlay_regions\nGet overlay regions only.\n\n\noverlays\nGet overlay region IDs from metadata.\n\n\npath_as_line\nMark regions as lines described in path notation.\n\n\nregion_types\nGet aesthetic element type for each region.\n\n\nrelabel\nRename or merge regions (returns new Outline object).\n\n\nset_overlays\nSet overlay region IDs in metadata (returns new Outline object).\n\n\nto_dict\nExport to dict in shinymap JSON format.\n\n\nto_json\nWrite outline to JSON file.\n\n\nunderlays\nGet underlay region IDs from metadata.\n\n\nupdate_metadata\nUpdate metadata (returns new Outline object).\n\n\nviewbox\nGet viewBox from metadata, or compute from outline coordinates.\n\n\n\n\n\nOutline.from_dict(data)\nLoad outline from dict (supports v0.x strings and v1.x element dicts).\nAutomatically detects format and converts: - v0.x: String paths → kept as strings (backward compatible) - v1.x: Element dicts → deserialized to Element objects\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\ndict[str, Any]\nDictionary with regions and optional _metadata key\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nOutline object with normalized list-based regions\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf _metadata exists but is not a dict\n\n\n\n\n\n\n&gt;&gt;&gt; # v0.x string format (backward compatible)\n&gt;&gt;&gt; outline = Outline.from_dict({\"a\": \"M 0 0 L 10 0\"})\n&gt;&gt;&gt; list(outline.regions.keys())\n['a']\n\n&gt;&gt;&gt; # v0.x list format\n&gt;&gt;&gt; outline = Outline.from_dict({\"a\": [\"M 0 0\", \"L 10 0\"]})\n&gt;&gt;&gt; outline.regions[\"a\"]\n['M 0 0', 'L 10 0']\n\n&gt;&gt;&gt; # v1.x element format\n&gt;&gt;&gt; data = {\"a\": [{\"type\": \"circle\", \"cx\": 100, \"cy\": 100, \"r\": 50}]}\n&gt;&gt;&gt; outline = Outline.from_dict(data)\n&gt;&gt;&gt; outline.regions[\"a\"]\n[Circle(cx=100, cy=100, r=50)]\n\n\n\n\nOutline.from_json(json_path)\nLoad outline from JSON file.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\njson_path\nstr | PathType\nPath to JSON file in shinymap format\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nOutline object with normalized list-based paths\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_json(\"japan_prefectures.json\")  # doctest: +SKIP\n&gt;&gt;&gt; geo.regions.keys()  # doctest: +SKIP\ndict_keys(['01', '02', ...])\n\n\n\n\nOutline.from_svg(svg_path, extract_viewbox=True)\nExtract outline from SVG file (all element types).\nExtracts all supported SVG shape elements (path, circle, rect, polygon, ellipse, line, text) and generates auto-IDs for elements without IDs. This is v1.0 behavior - returns polymorphic Element objects instead of path strings.\nPreserves SVG aesthetics (fill, stroke, etc.) but these are NOT used by shinymap for rendering. See class docstring for details.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsvg_path\nstr | PathType\nPath to input SVG file\nrequired\n\n\nextract_viewbox\nbool\nIf True, extract viewBox from SVG root element\nTrue\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nOutline object with extracted elements (v1.x format)\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nFileNotFoundError\nIf svg_path does not exist\n\n\n\nValueError\nIf SVG parsing fails\n\n\n\n\n\n\n&gt;&gt;&gt; # Basic extraction (all element types)\n&gt;&gt;&gt; geo = Outline.from_svg(\"design.svg\")  # doctest: +SKIP\n&gt;&gt;&gt; geo.regions.keys()  # doctest: +SKIP\ndict_keys(['circle_1', 'rect_1', 'path_1', 'text_1'])\n\n&gt;&gt;&gt; # With transformations\n&gt;&gt;&gt; geo = Outline.from_svg(\"map.svg\")  # doctest: +SKIP\n&gt;&gt;&gt; geo.relabel({\"hokkaido\": [\"circle_1\", \"circle_2\"]})  # doctest: +SKIP\n&gt;&gt;&gt; geo.set_overlays([\"_border\"])  # doctest: +SKIP\n&gt;&gt;&gt; geo.to_json(\"output.json\")  # doctest: +SKIP\n\n\n\n\nOutline.groups()\nGet group membership from metadata.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, list[str]]\nDict mapping group names to lists of region IDs\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region1\": [\"M 0 0\"],\n...     \"region2\": [\"M 10 0\"],\n...     \"_metadata\": {\"groups\": {\"coastal\": [\"region1\", \"region2\"]}}\n... })\n&gt;&gt;&gt; geo.groups()\n{'coastal': ['region1', 'region2']}\n\n\n\n\nOutline.hidden()\nGet hidden region IDs from metadata.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist[str]\nList of region IDs marked as hidden\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_temp\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"hidden\": [\"_temp\"]}\n... })\n&gt;&gt;&gt; geo.hidden()\n['_temp']\n\n\n\n\nOutline.layers_dict()\nGet layers configuration dict for JavaScript props.\nReturns a dict with overlays, underlays, and hidden keys if any layer configuration is present in metadata. Returns None if no layer configuration exists.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, list[str]] | None\nDict with layer configuration or None\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"], \"underlays\": [\"_bg\"]}\n... })\n&gt;&gt;&gt; geo.layers_dict()\n{'overlays': ['_border'], 'underlays': ['_bg']}\n\n\n\n\nOutline.main_regions()\nGet main regions (excluding overlays).\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRegions\nRegions object with main regions {regionId: [element1, …]}\n\n\n\nRegions\n(elements can be strings for v0.x or Element objects for v1.x)\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"]}\n... })\n&gt;&gt;&gt; geo.main_regions()\nRegions({\n  'region': ['M 0 0'],\n})\n\n\n\n\nOutline.merge_layers(layers)\nMerge provided layers with outline’s metadata overlays.\nReturns a new Outline with updated metadata containing the merged layers configuration. Explicit layers take priority over metadata overlays.\nThis method follows the immutable pattern - the original Outline is unchanged and a new Outline is returned.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlayers\ndict[str, list[str]] | None\nOptional explicit layer configuration with keys: underlays, overlays, hidden\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline with merged layers in metadata\n\n\n\n\n\n\n&gt;&gt;&gt; outline = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"]}\n... })\n&gt;&gt;&gt; merged = outline.merge_layers({\"underlays\": [\"_bg\"]})\n&gt;&gt;&gt; merged.metadata\n{'overlays': ['_border'], 'underlays': ['_bg']}\n&gt;&gt;&gt; merged = outline.merge_layers({\"overlays\": [\"_custom\"]})\n&gt;&gt;&gt; merged.metadata\n{'overlays': ['_custom']}\n\n\n\n\nOutline.metadata_dict(view_box=None)\nBuild outline metadata dict for JavaScript props.\nCreates the outlineMetadata object sent to React components, containing viewBox and groups information.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nview_box\ntuple[float, float, float, float] | None\nOptional override viewBox tuple. If None, uses self.viewbox()\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, Any] | None\nDict with viewBox and groups, or None if no metadata\n\n\n\n\n\n\n&gt;&gt;&gt; outline = Outline.from_dict({\n...     \"region1\": [\"M 0 0 L 100 100\"],\n...     \"_metadata\": {\"groups\": {\"coastal\": [\"region1\"]}}\n... })\n&gt;&gt;&gt; outline.metadata_dict()\n{'viewBox': '-2.0 -2.0 104.0 104.0', 'groups': {'coastal': ['region1']}}\n\n\n\n\nOutline.overlay_regions()\nGet overlay regions only.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRegions\nRegions object with overlay regions {regionId: [element1, …]}\n\n\n\nRegions\n(elements can be strings for v0.x or Element objects for v1.x)\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"]}\n... })\n&gt;&gt;&gt; geo.overlay_regions()\nRegions({\n  '_border': ['M 0 0 L 100 0'],\n})\n\n\n\n\nOutline.overlays()\nGet overlay region IDs from metadata.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist[str]\nList of region IDs marked as overlays\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"]}\n... })\n&gt;&gt;&gt; geo.overlays()\n['_border']\n\n\n\n\nOutline.path_as_line(*region_ids)\nMark regions as lines described in path notation.\nSome SVG paths represent lines (dividers, borders, grids) rather than filled shapes. This method stores the region IDs so that stroke-only aesthetics are automatically applied.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n*region_ids\nstr\nRegion IDs containing line elements in path notation\n()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline object with line regions recorded in metadata\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0 L 100 100\"],\n...     \"_divider\": [\"M 50 0 L 50 100\"]\n... })\n&gt;&gt;&gt; geo2 = geo.path_as_line(\"_divider\")\n&gt;&gt;&gt; # Now _divider will use stroke-only rendering\n\n\n\n\nOutline.region_types()\nGet aesthetic element type for each region.\nReturns a mapping of region_id -&gt; element_type where element_type is one of “shape”, “line”, or “text” for aesthetic resolution purposes.\nPriority: 1. metadata[“lines_as_path”] - explicit line override for path elements 2. Element’s element_name: - “line” → “line” - “text” → “text” - All others → “shape”\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, str]\nDict mapping region IDs to their aesthetic element types\n\n\n\n\n\n\n&gt;&gt;&gt; # v1.x format with mixed elements\n&gt;&gt;&gt; from shinymap.outline import Circle, Line, Text, Path\n&gt;&gt;&gt; outline = Outline(regions={\n...     \"region\": [Circle(cx=50, cy=50, r=30)],\n...     \"_divider\": [Line(x1=0, y1=50, x2=100, y2=50)],\n...     \"label\": [Text(x=50, y=50, text=\"A\")],\n... }, metadata={})\n&gt;&gt;&gt; outline.region_types()\n{'region': 'shape', '_divider': 'line', 'label': 'text'}\n\n&gt;&gt;&gt; # Path marked as line via path_as_line()\n&gt;&gt;&gt; outline = Outline(regions={\n...     \"_border\": [Path(d=\"M 0 0 L 100 0\")],\n... }, metadata={}).path_as_line(\"_border\")\n&gt;&gt;&gt; outline.region_types()\n{'_border': 'line'}\n\n\n\n\nOutline.relabel(mapping)\nRename or merge regions (returns new Outline object).\nThis method applies relabeling transformations to create a new Outline object with renamed or merged regions. Original object is unchanged.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmapping\ndict[str, str | list[str]]\nDict mapping new IDs to old ID(s) - String value: rename single region (e.g., {“tokyo”: “path_5”}) - List value: merge multiple regions (e.g., {“hokkaido”: [“path_1”, “path_2”]})\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline object with relabeled regions\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf an old ID in mapping doesn’t exist\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"path_1\": [\"M 0 0 L 10 0\"],\n...     \"path_2\": [\"M 20 0 L 30 0\"],\n...     \"path_3\": [\"M 40 0 L 50 0\"]\n... })\n&gt;&gt;&gt; # Rename and merge\n&gt;&gt;&gt; geo2 = geo.relabel({\n...     \"region_a\": [\"path_1\", \"path_2\"],  # Merge\n...     \"_border\": \"path_3\"                 # Rename\n... })\n&gt;&gt;&gt; geo2.regions.keys()\ndict_keys(['region_a', '_border'])\n\n\n\n\nOutline.set_overlays(overlay_ids)\nSet overlay region IDs in metadata (returns new Outline object).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noverlay_ids\nlist[str]\nList of region IDs to mark as overlays\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline object with updated overlay metadata\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"]\n... })\n&gt;&gt;&gt; geo2 = geo.set_overlays([\"_border\"])\n&gt;&gt;&gt; geo2.overlays()\n['_border']\n\n\n\n\nOutline.to_dict()\nExport to dict in shinymap JSON format.\nAutomatically serializes elements: - v0.x format: Strings are kept as-is - v1.x format: Element objects are serialized to dicts via to_dict()\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, Any]\nDict with _metadata and region data (v0.x strings or v1.x element dicts)\n\n\n\n\n\n\n&gt;&gt;&gt; # v0.x format (strings) - empty metadata is omitted\n&gt;&gt;&gt; outline = Outline.from_dict({\"region\": [\"M 0 0\"]})\n&gt;&gt;&gt; outline.to_dict()\n{'region': ['M 0 0']}\n\n&gt;&gt;&gt; # v1.x format (elements)\n&gt;&gt;&gt; from shinymap.outline import Circle\n&gt;&gt;&gt; outline = Outline(regions={\"r1\": [Circle(cx=100, cy=100, r=50)]}, metadata={})\n&gt;&gt;&gt; outline.to_dict()\n{'r1': [{'type': 'circle', 'cx': 100, 'cy': 100, 'r': 50}]}\n\n\n\n\nOutline.to_json(output_path)\nWrite outline to JSON file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noutput_path\nstr | PathType\nPath to write JSON file\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_svg(\"map.svg\")  # doctest: +SKIP\n&gt;&gt;&gt; geo.to_json(\"output.json\")  # doctest: +SKIP\n\n\n\n\nOutline.underlays()\nGet underlay region IDs from metadata.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist[str]\nList of region IDs marked as underlays\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_bg\": [\"M 0 0 L 100 0 L 100 100 L 0 100 Z\"],\n...     \"_metadata\": {\"underlays\": [\"_bg\"]}\n... })\n&gt;&gt;&gt; geo.underlays()\n['_bg']\n\n\n\n\nOutline.update_metadata(metadata)\nUpdate metadata (returns new Outline object).\nMerges provided metadata with existing metadata. Existing keys are overwritten by new values.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetadata\ndict[str, Any]\nDict of metadata to merge\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline object with updated metadata\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\"region\": [\"M 0 0\"]})\n&gt;&gt;&gt; geo2 = geo.update_metadata({\n...     \"source\": \"Wikimedia Commons\",\n...     \"license\": \"CC BY-SA 3.0\"\n... })\n&gt;&gt;&gt; geo2.metadata[\"source\"]\n'Wikimedia Commons'\n\n\n\n\nOutline.viewbox(padding=0.02)\nGet viewBox from metadata, or compute from outline coordinates.\nWorks with both v0.x (string paths) and v1.x (Element objects).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npadding\nfloat\nPadding fraction for computed viewBox (default 2%)\n0.02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ntuple[float, float, float, float]\nViewBox tuple in format (x, y, width, height)\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\"a\": [\"M 0 0 L 100 100\"]})\n&gt;&gt;&gt; geo.viewbox()  # Returns with 2% padding\n(-2.0, -2.0, 104.0, 104.0)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "shinymap",
    "section": "",
    "text": "Interactive SVG map components for Shiny (Python and R)."
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "shinymap",
    "section": "Overview",
    "text": "Overview\nshinymap provides visual alternatives to standard HTML form inputs using SVG regions:\n\ninput_map(mode=\"single\") - Visual radio buttons (select one region)\ninput_map(mode=\"multiple\") - Visual checkboxes (select multiple regions)\ninput_map(mode=Count()) - Visual counter (click to increment)\ninput_map(mode=Cycle(n)) - Visual state cycling (n discrete states)\n\nAdditionally, output_map provides simplified statistical visualizations (choropleths, categorical coloring) with a declarative API.\nNot just maps: Works with any SVG paths - geographic maps, diagrams, floor plans, anatomical illustrations, etc."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "shinymap",
    "section": "Installation",
    "text": "Installation\n\nPython\npip install shinymap\nOr with uv:\nuv add shinymap"
  },
  {
    "objectID": "index.html#quick-start",
    "href": "index.html#quick-start",
    "title": "shinymap",
    "section": "Quick Start",
    "text": "Quick Start\nfrom shiny import App, ui\nfrom shinymap import input_map, output_map, render_map, Map\nfrom shinymap.outline import Outline\n\n# Create simple geometry\nOUTLINE = Outline.from_dict({\n    \"circle\": [{\"type\": \"circle\", \"cx\": 25, \"cy\": 50, \"r\": 20}],\n    \"square\": [{\"type\": \"rect\", \"x\": 55, \"y\": 30, \"width\": 40, \"height\": 40}],\n    \"_metadata\": {\"viewBox\": \"0 0 100 100\"},\n})\n\napp_ui = ui.page_fluid(\n    ui.h2(\"shinymap demo\"),\n    ui.layout_columns(\n        input_map(\"region\", OUTLINE, mode=\"single\"),\n        output_map(\"result\", OUTLINE),\n    ),\n)\n\ndef server(input, output, session):\n    @render_map\n    def result():\n        selected = input.region()\n        value = {selected: 1} if selected else {}\n        return Map().with_value(value)\n\napp = App(app_ui, server)"
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "shinymap",
    "section": "Documentation",
    "text": "Documentation\n\nVignettes - Tutorials and use cases\nPython API - API reference\nTypeScript API - React component API"
  },
  {
    "objectID": "python/Map.html",
    "href": "python/Map.html",
    "title": "Map",
    "section": "",
    "text": "Map(\n    outline=None,\n    *,\n    view_box=None,\n    tooltips=None,\n    value=None,\n    aes=None,\n    layers=None,\n)\nCreate map from Outline object.\nWhen used with output_map() that provides static outline, you can call Map() without arguments. Otherwise, provide an Outline object.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noutline\nOutline | None\nOutline object with regions, viewBox, metadata. Optional when used with output_map()\nNone\n\n\nview_box\ntuple[float, float, float, float] | None\nOverride viewBox tuple (for zoom/pan). If None, uses outline.viewbox()\nNone\n\n\ntooltips\ndict[str, str] | None\nRegion tooltips\nNone\n\n\nvalue\ndict[str, int] | None\nRegion values (counts, selection state). Values determine both visual state and selection: - value = 0: not selected (base aesthetic) - value &gt; 0: selected (select aesthetic applied)\nNone\n\n\naes\nAesType\nAesthetic configuration (ByGroup, ByState, BaseAesthetic, or dict)\nNone\n\n\nlayers\nMapping[str, list[str] | None] | None\nLayer configuration (nested dict: underlays, overlays, hidden)\nNone\n\n\n\n\n\n\n# Standalone usage\ngeo = Outline.from_dict(data)\nMap(geo, value={\"a\": 1, \"b\": 1, \"c\": 0})\n\n# With output_map() providing static outline\noutput_map(\"my_map\", OUTLINE, tooltips=TOOLTIPS)\n@render_map\ndef my_map():\n    return Map().with_value(counts)\nReturns: MapBuilder instance for method chaining"
  },
  {
    "objectID": "python/Map.html#parameters",
    "href": "python/Map.html#parameters",
    "title": "Map",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\noutline\nOutline | None\nOutline object with regions, viewBox, metadata. Optional when used with output_map()\nNone\n\n\nview_box\ntuple[float, float, float, float] | None\nOverride viewBox tuple (for zoom/pan). If None, uses outline.viewbox()\nNone\n\n\ntooltips\ndict[str, str] | None\nRegion tooltips\nNone\n\n\nvalue\ndict[str, int] | None\nRegion values (counts, selection state). Values determine both visual state and selection: - value = 0: not selected (base aesthetic) - value &gt; 0: selected (select aesthetic applied)\nNone\n\n\naes\nAesType\nAesthetic configuration (ByGroup, ByState, BaseAesthetic, or dict)\nNone\n\n\nlayers\nMapping[str, list[str] | None] | None\nLayer configuration (nested dict: underlays, overlays, hidden)\nNone"
  },
  {
    "objectID": "python/Map.html#examples",
    "href": "python/Map.html#examples",
    "title": "Map",
    "section": "",
    "text": "# Standalone usage\ngeo = Outline.from_dict(data)\nMap(geo, value={\"a\": 1, \"b\": 1, \"c\": 0})\n\n# With output_map() providing static outline\noutput_map(\"my_map\", OUTLINE, tooltips=TOOLTIPS)\n@render_map\ndef my_map():\n    return Map().with_value(counts)\nReturns: MapBuilder instance for method chaining"
  },
  {
    "objectID": "python/PARENT.html",
    "href": "python/PARENT.html",
    "title": "PARENT",
    "section": "",
    "text": "PARENT\nPARENT"
  },
  {
    "objectID": "python/Wash.html",
    "href": "python/Wash.html",
    "title": "Wash",
    "section": "",
    "text": "Wash(shape=MISSING, line=MISSING, text=MISSING)\nCreate configured map functions with custom default aesthetics.\nWash() is like preparing a watercolor canvas - it sets the foundational layer that all maps in your app will build upon.\n\n\nshape Aesthetics for shape elements (Circle, Rect, Path, Polygon, Ellipse). Can be: - ByState: Full state configuration (base, select, hover) - ShapeAesthetic: Base state only (via aes.Shape()) - dict: Shorthand for base state (e.g., {“fill_color”: “#f0f9ff”}) - None: Shapes invisible/disabled - MISSING: Inherit library defaults line Aesthetics for line elements. Same value types as shape. text Aesthetics for text elements. Same value types as shape.\n\n\n\nWashResult An object with configured input_map, output_map, and render_map methods that use the wash’s default aesthetics.\n\n\n\nWash() only understands element types (shape, line, text). Group-specific aesthetics (like “coastal”, “mountain”) should be specified in input_map/output_map using the aes parameter with ByGroup.\n\n\n\n\n\n\nfrom shinymap import Wash, aes, Outline from shinymap.relative import PARENT\n\nwc = Wash( … shape=aes.ByState( … base=aes.Shape(fill_color=“#f0f9ff”, stroke_color=“#0369a1”), … select=aes.Shape(fill_color=“#7dd3fc”), … hover=aes.Shape(stroke_width=PARENT.stroke_width + 2), … ), … line=aes.ByState( … base=aes.Line(stroke_color=“#0369a1”), … hover=aes.Line(stroke_width=PARENT.stroke_width + 1), … ), … text=aes.Text(fill_color=“#0c4a6e”), # base only shorthand … )\n\nwc = Wash( … shape={“fill_color”: “#f0f9ff”, “stroke_color”: “#0369a1”}, … line={“stroke_color”: “#0369a1”}, … )\n\noutline = Outline.from_dict({“r1”: “M 0 0 L 10 10”}) _ = wc.input_map(“region”, outline, mode=“single”)"
  },
  {
    "objectID": "python/Wash.html#parameters",
    "href": "python/Wash.html#parameters",
    "title": "Wash",
    "section": "",
    "text": "shape Aesthetics for shape elements (Circle, Rect, Path, Polygon, Ellipse). Can be: - ByState: Full state configuration (base, select, hover) - ShapeAesthetic: Base state only (via aes.Shape()) - dict: Shorthand for base state (e.g., {“fill_color”: “#f0f9ff”}) - None: Shapes invisible/disabled - MISSING: Inherit library defaults line Aesthetics for line elements. Same value types as shape. text Aesthetics for text elements. Same value types as shape."
  },
  {
    "objectID": "python/Wash.html#returns",
    "href": "python/Wash.html#returns",
    "title": "Wash",
    "section": "",
    "text": "WashResult An object with configured input_map, output_map, and render_map methods that use the wash’s default aesthetics."
  },
  {
    "objectID": "python/Wash.html#notes",
    "href": "python/Wash.html#notes",
    "title": "Wash",
    "section": "",
    "text": "Wash() only understands element types (shape, line, text). Group-specific aesthetics (like “coastal”, “mountain”) should be specified in input_map/output_map using the aes parameter with ByGroup."
  },
  {
    "objectID": "python/Wash.html#examples",
    "href": "python/Wash.html#examples",
    "title": "Wash",
    "section": "",
    "text": "from shinymap import Wash, aes, Outline from shinymap.relative import PARENT\n\nwc = Wash( … shape=aes.ByState( … base=aes.Shape(fill_color=“#f0f9ff”, stroke_color=“#0369a1”), … select=aes.Shape(fill_color=“#7dd3fc”), … hover=aes.Shape(stroke_width=PARENT.stroke_width + 2), … ), … line=aes.ByState( … base=aes.Line(stroke_color=“#0369a1”), … hover=aes.Line(stroke_width=PARENT.stroke_width + 1), … ), … text=aes.Text(fill_color=“#0c4a6e”), # base only shorthand … )\n\nwc = Wash( … shape={“fill_color”: “#f0f9ff”, “stroke_color”: “#0369a1”}, … line={“stroke_color”: “#0369a1”}, … )\n\noutline = Outline.from_dict({“r1”: “M 0 0 L 10 10”}) _ = wc.input_map(“region”, outline, mode=“single”)"
  },
  {
    "objectID": "python/aes.ByState.html",
    "href": "python/aes.ByState.html",
    "title": "aes.ByState",
    "section": "",
    "text": "aes.ByState(base=MISSING, *, select=MISSING, hover=MISSING)\nContainer for element aesthetics across interaction states.\nGroups base, select, and hover aesthetics for a single element type. The type parameter T is constrained to BaseAesthetic subclasses (ShapeAesthetic, LineAesthetic, TextAesthetic).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbase\nT | None | MissingType\nAesthetic for the default/base state (positional). MISSING = inherit from library default, None = invisible.\nMISSING\n\n\nselect\nT | None | MissingType\nAesthetic override when region is selected. MISSING = inherit from base, None = no selection effect.\nMISSING\n\n\nhover\nT | None | MissingType\nAesthetic override when region is hovered. MISSING = inherit library default hover, None = no hover effect.\nMISSING\n\n\n\n\n\n\n&gt;&gt;&gt; from shinymap import aes, PARENT\n\n&gt;&gt;&gt; # Full form with all states\n&gt;&gt;&gt; shape_states = aes.ByState(\n...     aes.Shape(fill_color=\"#f0f9ff\"),\n...     select=aes.Shape(fill_color=\"#7dd3fc\"),\n...     hover=aes.Shape(stroke_width=PARENT.stroke_width + 2),\n... )\n\n&gt;&gt;&gt; # Base only (select/hover inherit defaults)\n&gt;&gt;&gt; line_states = aes.ByState(aes.Line(stroke_color=\"#0369a1\"))\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_dict\nConvert dict with base/select/hover keys to ByState.\n\n\nresolve_for_region\nResolve the final aesthetic for a region given its state.\n\n\nto_dict\nConvert to dict with type key, recursively converting nested aesthetics.\n\n\nto_js_dict\nConvert to dict format for JavaScript consumption.\n\n\n\n\n\naes.ByState.from_dict(d)\nConvert dict with base/select/hover keys to ByState.\nRecursively deserializes nested aesthetic dicts using _leaf_from_dict().\n\n\n\naes.ByState.resolve_for_region(\n    wash_default,\n    is_selected=False,\n    is_hovered=False,\n)\nResolve the final aesthetic for a region given its state.\nChain: wash_default → base → select (if selected) → hover (if hovered)\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwash_default\nBaseAesthetic\nThe wash config default aesthetic for this element type\nrequired\n\n\nis_selected\nbool\nWhether the region is currently selected\nFalse\n\n\nis_hovered\nbool\nWhether the region is currently hovered\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nBaseAesthetic\nA fully resolved aesthetic\n\n\n\n\n\n\n&gt;&gt;&gt; from shinymap import aes, PARENT\n&gt;&gt;&gt; default = aes.Shape(fill_color=\"#e5e7eb\", stroke_width=1.0)\n&gt;&gt;&gt; states = aes.ByState(\n...     base=aes.Shape(fill_color=\"#3b82f6\"),\n...     select=aes.Shape(fill_color=\"#1e40af\"),\n...     hover=aes.Shape(stroke_width=PARENT.stroke_width + 1),\n... )\n&gt;&gt;&gt; # Not selected, not hovered\n&gt;&gt;&gt; resolved = states.resolve_for_region(default)\n&gt;&gt;&gt; resolved.fill_color\n'#3b82f6'\n&gt;&gt;&gt; resolved.stroke_width  # inherited from default\n1.0\n&gt;&gt;&gt; # Selected and hovered\n&gt;&gt;&gt; resolved = states.resolve_for_region(default, is_selected=True, is_hovered=True)\n&gt;&gt;&gt; resolved.fill_color  # from select\n'#1e40af'\n&gt;&gt;&gt; resolved.stroke_width  # 1.0 + 1 from hover\n2.0\n\n\n\n\naes.ByState.to_dict()\nConvert to dict with type key, recursively converting nested aesthetics.\n\n\n\naes.ByState.to_js_dict()\nConvert to dict format for JavaScript consumption.\nUnlike to_dict(), this produces a simplified format without type discriminators, suitable for direct use by React components.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, Any]\nDict with keys: base, select, hover\n\n\n\ndict[str, Any]\nEach value is a dict of aesthetic properties (snake_case keys)."
  },
  {
    "objectID": "python/aes.ByState.html#parameters",
    "href": "python/aes.ByState.html#parameters",
    "title": "aes.ByState",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nbase\nT | None | MissingType\nAesthetic for the default/base state (positional). MISSING = inherit from library default, None = invisible.\nMISSING\n\n\nselect\nT | None | MissingType\nAesthetic override when region is selected. MISSING = inherit from base, None = no selection effect.\nMISSING\n\n\nhover\nT | None | MissingType\nAesthetic override when region is hovered. MISSING = inherit library default hover, None = no hover effect.\nMISSING"
  },
  {
    "objectID": "python/aes.ByState.html#examples",
    "href": "python/aes.ByState.html#examples",
    "title": "aes.ByState",
    "section": "",
    "text": "&gt;&gt;&gt; from shinymap import aes, PARENT\n\n&gt;&gt;&gt; # Full form with all states\n&gt;&gt;&gt; shape_states = aes.ByState(\n...     aes.Shape(fill_color=\"#f0f9ff\"),\n...     select=aes.Shape(fill_color=\"#7dd3fc\"),\n...     hover=aes.Shape(stroke_width=PARENT.stroke_width + 2),\n... )\n\n&gt;&gt;&gt; # Base only (select/hover inherit defaults)\n&gt;&gt;&gt; line_states = aes.ByState(aes.Line(stroke_color=\"#0369a1\"))"
  },
  {
    "objectID": "python/aes.ByState.html#methods",
    "href": "python/aes.ByState.html#methods",
    "title": "aes.ByState",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfrom_dict\nConvert dict with base/select/hover keys to ByState.\n\n\nresolve_for_region\nResolve the final aesthetic for a region given its state.\n\n\nto_dict\nConvert to dict with type key, recursively converting nested aesthetics.\n\n\nto_js_dict\nConvert to dict format for JavaScript consumption.\n\n\n\n\n\naes.ByState.from_dict(d)\nConvert dict with base/select/hover keys to ByState.\nRecursively deserializes nested aesthetic dicts using _leaf_from_dict().\n\n\n\naes.ByState.resolve_for_region(\n    wash_default,\n    is_selected=False,\n    is_hovered=False,\n)\nResolve the final aesthetic for a region given its state.\nChain: wash_default → base → select (if selected) → hover (if hovered)\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwash_default\nBaseAesthetic\nThe wash config default aesthetic for this element type\nrequired\n\n\nis_selected\nbool\nWhether the region is currently selected\nFalse\n\n\nis_hovered\nbool\nWhether the region is currently hovered\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nBaseAesthetic\nA fully resolved aesthetic\n\n\n\n\n\n\n&gt;&gt;&gt; from shinymap import aes, PARENT\n&gt;&gt;&gt; default = aes.Shape(fill_color=\"#e5e7eb\", stroke_width=1.0)\n&gt;&gt;&gt; states = aes.ByState(\n...     base=aes.Shape(fill_color=\"#3b82f6\"),\n...     select=aes.Shape(fill_color=\"#1e40af\"),\n...     hover=aes.Shape(stroke_width=PARENT.stroke_width + 1),\n... )\n&gt;&gt;&gt; # Not selected, not hovered\n&gt;&gt;&gt; resolved = states.resolve_for_region(default)\n&gt;&gt;&gt; resolved.fill_color\n'#3b82f6'\n&gt;&gt;&gt; resolved.stroke_width  # inherited from default\n1.0\n&gt;&gt;&gt; # Selected and hovered\n&gt;&gt;&gt; resolved = states.resolve_for_region(default, is_selected=True, is_hovered=True)\n&gt;&gt;&gt; resolved.fill_color  # from select\n'#1e40af'\n&gt;&gt;&gt; resolved.stroke_width  # 1.0 + 1 from hover\n2.0\n\n\n\n\naes.ByState.to_dict()\nConvert to dict with type key, recursively converting nested aesthetics.\n\n\n\naes.ByState.to_js_dict()\nConvert to dict format for JavaScript consumption.\nUnlike to_dict(), this produces a simplified format without type discriminators, suitable for direct use by React components.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, Any]\nDict with keys: base, select, hover\n\n\n\ndict[str, Any]\nEach value is a dict of aesthetic properties (snake_case keys)."
  },
  {
    "objectID": "python/aes.Line.html",
    "href": "python/aes.Line.html",
    "title": "aes.Line",
    "section": "",
    "text": "aes.Line(\n    stroke_color=MISSING,\n    stroke_width=MISSING,\n    stroke_dasharray=MISSING,\n    non_scaling_stroke=MISSING,\n)\nCreate line aesthetic (stroke only, no fill).\nUse for line elements where only stroke properties are relevant.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstroke_color\nstr | None | MissingType\nStroke color (e.g., “#ddd”). None means “none” in SVG.\nMISSING\n\n\nstroke_width\nfloat | RelativeExpr | None | MissingType\nStroke width in viewBox units, or RelativeExpr for parent-relative values\nMISSING\n\n\nstroke_dasharray\nstr | None | MissingType\nDash pattern (e.g., “5,5” for dashed). Use aes.line constants.\nMISSING\n\n\nnon_scaling_stroke\nbool | MissingType\nIf True, stroke width is in screen pixels (default: False)\nMISSING\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nLineAesthetic\nLineAesthetic instance\n\n\n\n\n\n\n&gt;&gt;&gt; from shinymap import aes\n&gt;&gt;&gt; grid_aes = aes.Line(stroke_color=\"#ddd\", stroke_dasharray=aes.line.dashed)"
  },
  {
    "objectID": "python/aes.Line.html#parameters",
    "href": "python/aes.Line.html#parameters",
    "title": "aes.Line",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nstroke_color\nstr | None | MissingType\nStroke color (e.g., “#ddd”). None means “none” in SVG.\nMISSING\n\n\nstroke_width\nfloat | RelativeExpr | None | MissingType\nStroke width in viewBox units, or RelativeExpr for parent-relative values\nMISSING\n\n\nstroke_dasharray\nstr | None | MissingType\nDash pattern (e.g., “5,5” for dashed). Use aes.line constants.\nMISSING\n\n\nnon_scaling_stroke\nbool | MissingType\nIf True, stroke width is in screen pixels (default: False)\nMISSING"
  },
  {
    "objectID": "python/aes.Line.html#returns",
    "href": "python/aes.Line.html#returns",
    "title": "aes.Line",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nLineAesthetic\nLineAesthetic instance"
  },
  {
    "objectID": "python/aes.Line.html#examples",
    "href": "python/aes.Line.html#examples",
    "title": "aes.Line",
    "section": "",
    "text": "&gt;&gt;&gt; from shinymap import aes\n&gt;&gt;&gt; grid_aes = aes.Line(stroke_color=\"#ddd\", stroke_dasharray=aes.line.dashed)"
  },
  {
    "objectID": "python/aes.color.scale_diverging.html",
    "href": "python/aes.color.scale_diverging.html",
    "title": "aes.color.scale_diverging",
    "section": "",
    "text": "aes.color.scale_diverging(\n    values,\n    region_ids,\n    low_color='#ef4444',\n    mid_color='#f3f4f6',\n    high_color='#3b82f6',\n    midpoint=0.0,\n)\nCreate a diverging color scale (red-white-blue style).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalues\nMapping[str, float]\nMapping of region_id to numeric value\nrequired\n\n\nregion_ids\nlist[str]\nAll region IDs to include\nrequired\n\n\nlow_color\nstr\nColor for low values\n'#ef4444'\n\n\nmid_color\nstr\nColor for midpoint value\n'#f3f4f6'\n\n\nhigh_color\nstr\nColor for high values\n'#3b82f6'\n\n\nmidpoint\nfloat\nValue that maps to mid_color\n0.0\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, str]\nMapping of region_id to hex color"
  },
  {
    "objectID": "python/aes.color.scale_diverging.html#parameters",
    "href": "python/aes.color.scale_diverging.html#parameters",
    "title": "aes.color.scale_diverging",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nvalues\nMapping[str, float]\nMapping of region_id to numeric value\nrequired\n\n\nregion_ids\nlist[str]\nAll region IDs to include\nrequired\n\n\nlow_color\nstr\nColor for low values\n'#ef4444'\n\n\nmid_color\nstr\nColor for midpoint value\n'#f3f4f6'\n\n\nhigh_color\nstr\nColor for high values\n'#3b82f6'\n\n\nmidpoint\nfloat\nValue that maps to mid_color\n0.0"
  },
  {
    "objectID": "python/aes.color.scale_diverging.html#returns",
    "href": "python/aes.color.scale_diverging.html#returns",
    "title": "aes.color.scale_diverging",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\ndict[str, str]\nMapping of region_id to hex color"
  },
  {
    "objectID": "python/aes.color.scale_sequential.html",
    "href": "python/aes.color.scale_sequential.html",
    "title": "aes.color.scale_sequential",
    "section": "",
    "text": "aes.color.scale_sequential(\n    counts,\n    region_ids,\n    palette=SEQUENTIAL_BLUE,\n    neutral_color=NEUTRALS['fill'],\n    max_count=None,\n)\nCreate a sequential color scale based on counts.\nRegions with count=0 get the neutral color. Regions with counts are colored from palette[0] (low) to palette[-1] (high).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncounts\nMapping[str, int]\nMapping of region_id to count\nrequired\n\n\nregion_ids\nlist[str]\nAll region IDs to include\nrequired\n\n\npalette\nlist[str]\nColor palette to use (default: SEQUENTIAL_BLUE)\nSEQUENTIAL_BLUE\n\n\nneutral_color\nstr\nColor for regions with count=0\nNEUTRALS['fill']\n\n\nmax_count\nint | None\nFixed maximum for scaling. If None, uses dynamic max from counts. For interactive visualizations, use a fixed value to prevent other regions from changing color when one region is clicked.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, str]\nMapping of region_id to hex color"
  },
  {
    "objectID": "python/aes.color.scale_sequential.html#parameters",
    "href": "python/aes.color.scale_sequential.html#parameters",
    "title": "aes.color.scale_sequential",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ncounts\nMapping[str, int]\nMapping of region_id to count\nrequired\n\n\nregion_ids\nlist[str]\nAll region IDs to include\nrequired\n\n\npalette\nlist[str]\nColor palette to use (default: SEQUENTIAL_BLUE)\nSEQUENTIAL_BLUE\n\n\nneutral_color\nstr\nColor for regions with count=0\nNEUTRALS['fill']\n\n\nmax_count\nint | None\nFixed maximum for scaling. If None, uses dynamic max from counts. For interactive visualizations, use a fixed value to prevent other regions from changing color when one region is clicked.\nNone"
  },
  {
    "objectID": "python/aes.color.scale_sequential.html#returns",
    "href": "python/aes.color.scale_sequential.html#returns",
    "title": "aes.color.scale_sequential",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\ndict[str, str]\nMapping of region_id to hex color"
  },
  {
    "objectID": "python/input_map.html",
    "href": "python/input_map.html",
    "title": "input_map",
    "section": "",
    "text": "input_map\ninput_map"
  },
  {
    "objectID": "python/mode.Cycle.html",
    "href": "python/mode.Cycle.html",
    "title": "mode.Cycle",
    "section": "",
    "text": "mode.Cycle(n, values=None, aes=None)\nCycle mode - finite state cycling (e.g., traffic light survey).\nEach click cycles through n states: 0 -&gt; 1 -&gt; 2 -&gt; … -&gt; n-1 -&gt; 0. Use with aes.Indexed to define visual appearance for each state.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of states (e.g., 4 for gray-&gt;red-&gt;yellow-&gt;green-&gt;gray).\nrequired\n\n\nvalues\ndict[str, int] | None\nInitial state per region {id: state_index}. Default: all 0.\nNone\n\n\naes\nIndexedAesthetic | ByGroup | None\nIndexed aesthetic with styles for each state. Can be aes.Indexed (global) or aes.ByGroup wrapping aes.Indexed. Index is computed as: count % n (wrapping).\nNone\n\n\n\n\n\n\n&gt;&gt;&gt; from shinymap.mode import Cycle\n&gt;&gt;&gt; from shinymap import aes\n&gt;&gt;&gt; from shinymap.aes.color import HUE_CYCLE_4\n\n&gt;&gt;&gt; # Traffic light survey (4 states)\n&gt;&gt;&gt; mode = Cycle(\n...     n=4,\n...     aes=aes.Indexed(fill_color=HUE_CYCLE_4),\n... )\n\n&gt;&gt;&gt; # Per-group palettes (color coordination quiz)\n&gt;&gt;&gt; mode = Cycle(\n...     n=2,\n...     aes=aes.ByGroup(\n...         question_1=aes.Indexed(fill_color=[\"#bfdbfe\", \"#2563eb\"]),\n...         question_2=aes.Indexed(fill_color=[\"#bbf7d0\", \"#16a34a\"]),\n...     ),\n... )\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_dict\nSerialize for JavaScript (snake_case, JS converts to camelCase).\n\n\n\n\n\nmode.Cycle.to_dict()\nSerialize for JavaScript (snake_case, JS converts to camelCase)."
  },
  {
    "objectID": "python/mode.Cycle.html#parameters",
    "href": "python/mode.Cycle.html#parameters",
    "title": "mode.Cycle",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of states (e.g., 4 for gray-&gt;red-&gt;yellow-&gt;green-&gt;gray).\nrequired\n\n\nvalues\ndict[str, int] | None\nInitial state per region {id: state_index}. Default: all 0.\nNone\n\n\naes\nIndexedAesthetic | ByGroup | None\nIndexed aesthetic with styles for each state. Can be aes.Indexed (global) or aes.ByGroup wrapping aes.Indexed. Index is computed as: count % n (wrapping).\nNone"
  },
  {
    "objectID": "python/mode.Cycle.html#examples",
    "href": "python/mode.Cycle.html#examples",
    "title": "mode.Cycle",
    "section": "",
    "text": "&gt;&gt;&gt; from shinymap.mode import Cycle\n&gt;&gt;&gt; from shinymap import aes\n&gt;&gt;&gt; from shinymap.aes.color import HUE_CYCLE_4\n\n&gt;&gt;&gt; # Traffic light survey (4 states)\n&gt;&gt;&gt; mode = Cycle(\n...     n=4,\n...     aes=aes.Indexed(fill_color=HUE_CYCLE_4),\n... )\n\n&gt;&gt;&gt; # Per-group palettes (color coordination quiz)\n&gt;&gt;&gt; mode = Cycle(\n...     n=2,\n...     aes=aes.ByGroup(\n...         question_1=aes.Indexed(fill_color=[\"#bfdbfe\", \"#2563eb\"]),\n...         question_2=aes.Indexed(fill_color=[\"#bbf7d0\", \"#16a34a\"]),\n...     ),\n... )"
  },
  {
    "objectID": "python/mode.Cycle.html#methods",
    "href": "python/mode.Cycle.html#methods",
    "title": "mode.Cycle",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nto_dict\nSerialize for JavaScript (snake_case, JS converts to camelCase).\n\n\n\n\n\nmode.Cycle.to_dict()\nSerialize for JavaScript (snake_case, JS converts to camelCase)."
  },
  {
    "objectID": "python/mode.Multiple.html",
    "href": "python/mode.Multiple.html",
    "title": "mode.Multiple",
    "section": "",
    "text": "mode.Multiple(selected=None, max_selection=None, aes=None)\nMultiple selection mode with customization options.\nUse when you need options beyond the simple mode=“multiple” string: - Initial selections - Selection limit (max_selection) - Custom two-state aesthetics\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nselected\nlist[str] | None\nInitially selected region IDs.\nNone\n\n\nmax_selection\nint | None\nMaximum number of selections allowed. None = unlimited.\nNone\n\n\naes\nIndexedAesthetic | ByGroup | None\nTwo-state aesthetic [unselected, selected]. Can be aes.Indexed (global) or aes.ByGroup wrapping aes.Indexed.\nNone\n\n\n\n\n\n\n&gt;&gt;&gt; from shinymap.mode import Multiple\n&gt;&gt;&gt; from shinymap import aes\n\n&gt;&gt;&gt; # Limit to 3 selections\n&gt;&gt;&gt; mode = Multiple(max_selection=3)\n\n&gt;&gt;&gt; # Pre-select regions\n&gt;&gt;&gt; mode = Multiple(selected=[\"region_a\", \"region_b\"])\n\n&gt;&gt;&gt; # Custom selection colors with limit\n&gt;&gt;&gt; mode = Multiple(\n...     max_selection=5,\n...     aes=aes.Indexed(\n...         fill_color=[\"#e5e7eb\", \"#10b981\"],  # gray -&gt; green\n...     )\n... )\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nto_dict\nSerialize for JavaScript (snake_case, JS converts to camelCase).\n\n\n\n\n\nmode.Multiple.to_dict()\nSerialize for JavaScript (snake_case, JS converts to camelCase)."
  },
  {
    "objectID": "python/mode.Multiple.html#parameters",
    "href": "python/mode.Multiple.html#parameters",
    "title": "mode.Multiple",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nselected\nlist[str] | None\nInitially selected region IDs.\nNone\n\n\nmax_selection\nint | None\nMaximum number of selections allowed. None = unlimited.\nNone\n\n\naes\nIndexedAesthetic | ByGroup | None\nTwo-state aesthetic [unselected, selected]. Can be aes.Indexed (global) or aes.ByGroup wrapping aes.Indexed.\nNone"
  },
  {
    "objectID": "python/mode.Multiple.html#examples",
    "href": "python/mode.Multiple.html#examples",
    "title": "mode.Multiple",
    "section": "",
    "text": "&gt;&gt;&gt; from shinymap.mode import Multiple\n&gt;&gt;&gt; from shinymap import aes\n\n&gt;&gt;&gt; # Limit to 3 selections\n&gt;&gt;&gt; mode = Multiple(max_selection=3)\n\n&gt;&gt;&gt; # Pre-select regions\n&gt;&gt;&gt; mode = Multiple(selected=[\"region_a\", \"region_b\"])\n\n&gt;&gt;&gt; # Custom selection colors with limit\n&gt;&gt;&gt; mode = Multiple(\n...     max_selection=5,\n...     aes=aes.Indexed(\n...         fill_color=[\"#e5e7eb\", \"#10b981\"],  # gray -&gt; green\n...     )\n... )"
  },
  {
    "objectID": "python/mode.Multiple.html#methods",
    "href": "python/mode.Multiple.html#methods",
    "title": "mode.Multiple",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nto_dict\nSerialize for JavaScript (snake_case, JS converts to camelCase).\n\n\n\n\n\nmode.Multiple.to_dict()\nSerialize for JavaScript (snake_case, JS converts to camelCase)."
  },
  {
    "objectID": "python/outline.Outline.html",
    "href": "python/outline.Outline.html",
    "title": "outline.Outline",
    "section": "",
    "text": "outline.Outline(regions, metadata=dict())\nCanonical outline representation with polymorphic elements.\nThis class encapsulates SVG outline with metadata. It supports both: - v0.x format: String-based paths (for backward compatibility) - v1.x format: Polymorphic element objects (Circle, Rect, Path, etc.)\nThe class automatically converts between formats for seamless migration.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nregions\nRegions\nRegions object (dict subclass) mapping region IDs to lists of elements (str for v0.x compatibility, Element objects for v1.x)\n\n\nmetadata\ndict[str, Any]\nOptional metadata dict (viewBox, overlays, source, license, etc.)\n\n\n\n\n\n\nSVG elements preserve aesthetic attributes (fill, stroke, etc.) but these are NOT used by shinymap for rendering. Interactive appearance is controlled via Python API. Preserved values are for SVG export and reference only.\n\n\n\n&gt;&gt;&gt; # v0.x format (backward compatible)\n&gt;&gt;&gt; data = {\"region1\": [\"M 0 0 L 10 0\"], \"_metadata\": {\"viewBox\": \"0 0 100 100\"}}\n&gt;&gt;&gt; geo = Outline.from_dict(data)\n\n&gt;&gt;&gt; # v1.x format (polymorphic elements)\n&gt;&gt;&gt; from shinymap.outline import Circle\n&gt;&gt;&gt; geo = Outline(regions={\"r1\": [Circle(cx=100, cy=100, r=50)]}, metadata={})\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_dict\nLoad outline from dict (supports v0.x strings and v1.x element dicts).\n\n\nfrom_json\nLoad outline from JSON file.\n\n\nfrom_svg\nExtract outline from SVG file (all element types).\n\n\ngroups\nGet group membership from metadata.\n\n\nhidden\nGet hidden region IDs from metadata.\n\n\nlayers_dict\nGet layers configuration dict for JavaScript props.\n\n\nmain_regions\nGet main regions (excluding overlays).\n\n\nmerge_layers\nMerge provided layers with outline’s metadata overlays.\n\n\nmetadata_dict\nBuild outline metadata dict for JavaScript props.\n\n\noverlay_regions\nGet overlay regions only.\n\n\noverlays\nGet overlay region IDs from metadata.\n\n\npath_as_line\nMark regions as lines described in path notation.\n\n\nregion_types\nGet aesthetic element type for each region.\n\n\nrelabel\nRename or merge regions (returns new Outline object).\n\n\nset_overlays\nSet overlay region IDs in metadata (returns new Outline object).\n\n\nto_dict\nExport to dict in shinymap JSON format.\n\n\nto_json\nWrite outline to JSON file.\n\n\nunderlays\nGet underlay region IDs from metadata.\n\n\nupdate_metadata\nUpdate metadata (returns new Outline object).\n\n\nviewbox\nGet viewBox from metadata, or compute from outline coordinates.\n\n\n\n\n\noutline.Outline.from_dict(data)\nLoad outline from dict (supports v0.x strings and v1.x element dicts).\nAutomatically detects format and converts: - v0.x: String paths → kept as strings (backward compatible) - v1.x: Element dicts → deserialized to Element objects\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\ndict[str, Any]\nDictionary with regions and optional _metadata key\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nOutline object with normalized list-based regions\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf _metadata exists but is not a dict\n\n\n\n\n\n\n&gt;&gt;&gt; # v0.x string format (backward compatible)\n&gt;&gt;&gt; outline = Outline.from_dict({\"a\": \"M 0 0 L 10 0\"})\n&gt;&gt;&gt; list(outline.regions.keys())\n['a']\n\n&gt;&gt;&gt; # v0.x list format\n&gt;&gt;&gt; outline = Outline.from_dict({\"a\": [\"M 0 0\", \"L 10 0\"]})\n&gt;&gt;&gt; outline.regions[\"a\"]\n['M 0 0', 'L 10 0']\n\n&gt;&gt;&gt; # v1.x element format\n&gt;&gt;&gt; data = {\"a\": [{\"type\": \"circle\", \"cx\": 100, \"cy\": 100, \"r\": 50}]}\n&gt;&gt;&gt; outline = Outline.from_dict(data)\n&gt;&gt;&gt; outline.regions[\"a\"]\n[Circle(cx=100, cy=100, r=50)]\n\n\n\n\noutline.Outline.from_json(json_path)\nLoad outline from JSON file.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\njson_path\nstr | PathType\nPath to JSON file in shinymap format\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nOutline object with normalized list-based paths\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_json(\"japan_prefectures.json\")  # doctest: +SKIP\n&gt;&gt;&gt; geo.regions.keys()  # doctest: +SKIP\ndict_keys(['01', '02', ...])\n\n\n\n\noutline.Outline.from_svg(svg_path, extract_viewbox=True)\nExtract outline from SVG file (all element types).\nExtracts all supported SVG shape elements (path, circle, rect, polygon, ellipse, line, text) and generates auto-IDs for elements without IDs. This is v1.0 behavior - returns polymorphic Element objects instead of path strings.\nPreserves SVG aesthetics (fill, stroke, etc.) but these are NOT used by shinymap for rendering. See class docstring for details.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsvg_path\nstr | PathType\nPath to input SVG file\nrequired\n\n\nextract_viewbox\nbool\nIf True, extract viewBox from SVG root element\nTrue\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nOutline object with extracted elements (v1.x format)\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nFileNotFoundError\nIf svg_path does not exist\n\n\n\nValueError\nIf SVG parsing fails\n\n\n\n\n\n\n&gt;&gt;&gt; # Basic extraction (all element types)\n&gt;&gt;&gt; geo = Outline.from_svg(\"design.svg\")  # doctest: +SKIP\n&gt;&gt;&gt; geo.regions.keys()  # doctest: +SKIP\ndict_keys(['circle_1', 'rect_1', 'path_1', 'text_1'])\n\n&gt;&gt;&gt; # With transformations\n&gt;&gt;&gt; geo = Outline.from_svg(\"map.svg\")  # doctest: +SKIP\n&gt;&gt;&gt; geo.relabel({\"hokkaido\": [\"circle_1\", \"circle_2\"]})  # doctest: +SKIP\n&gt;&gt;&gt; geo.set_overlays([\"_border\"])  # doctest: +SKIP\n&gt;&gt;&gt; geo.to_json(\"output.json\")  # doctest: +SKIP\n\n\n\n\noutline.Outline.groups()\nGet group membership from metadata.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, list[str]]\nDict mapping group names to lists of region IDs\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region1\": [\"M 0 0\"],\n...     \"region2\": [\"M 10 0\"],\n...     \"_metadata\": {\"groups\": {\"coastal\": [\"region1\", \"region2\"]}}\n... })\n&gt;&gt;&gt; geo.groups()\n{'coastal': ['region1', 'region2']}\n\n\n\n\noutline.Outline.hidden()\nGet hidden region IDs from metadata.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist[str]\nList of region IDs marked as hidden\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_temp\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"hidden\": [\"_temp\"]}\n... })\n&gt;&gt;&gt; geo.hidden()\n['_temp']\n\n\n\n\noutline.Outline.layers_dict()\nGet layers configuration dict for JavaScript props.\nReturns a dict with overlays, underlays, and hidden keys if any layer configuration is present in metadata. Returns None if no layer configuration exists.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, list[str]] | None\nDict with layer configuration or None\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"], \"underlays\": [\"_bg\"]}\n... })\n&gt;&gt;&gt; geo.layers_dict()\n{'overlays': ['_border'], 'underlays': ['_bg']}\n\n\n\n\noutline.Outline.main_regions()\nGet main regions (excluding overlays).\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRegions\nRegions object with main regions {regionId: [element1, …]}\n\n\n\nRegions\n(elements can be strings for v0.x or Element objects for v1.x)\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"]}\n... })\n&gt;&gt;&gt; geo.main_regions()\nRegions({\n  'region': ['M 0 0'],\n})\n\n\n\n\noutline.Outline.merge_layers(layers)\nMerge provided layers with outline’s metadata overlays.\nReturns a new Outline with updated metadata containing the merged layers configuration. Explicit layers take priority over metadata overlays.\nThis method follows the immutable pattern - the original Outline is unchanged and a new Outline is returned.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlayers\ndict[str, list[str]] | None\nOptional explicit layer configuration with keys: underlays, overlays, hidden\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline with merged layers in metadata\n\n\n\n\n\n\n&gt;&gt;&gt; outline = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"]}\n... })\n&gt;&gt;&gt; merged = outline.merge_layers({\"underlays\": [\"_bg\"]})\n&gt;&gt;&gt; merged.metadata\n{'overlays': ['_border'], 'underlays': ['_bg']}\n&gt;&gt;&gt; merged = outline.merge_layers({\"overlays\": [\"_custom\"]})\n&gt;&gt;&gt; merged.metadata\n{'overlays': ['_custom']}\n\n\n\n\noutline.Outline.metadata_dict(view_box=None)\nBuild outline metadata dict for JavaScript props.\nCreates the outlineMetadata object sent to React components, containing viewBox and groups information.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nview_box\ntuple[float, float, float, float] | None\nOptional override viewBox tuple. If None, uses self.viewbox()\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, Any] | None\nDict with viewBox and groups, or None if no metadata\n\n\n\n\n\n\n&gt;&gt;&gt; outline = Outline.from_dict({\n...     \"region1\": [\"M 0 0 L 100 100\"],\n...     \"_metadata\": {\"groups\": {\"coastal\": [\"region1\"]}}\n... })\n&gt;&gt;&gt; outline.metadata_dict()\n{'viewBox': '-2.0 -2.0 104.0 104.0', 'groups': {'coastal': ['region1']}}\n\n\n\n\noutline.Outline.overlay_regions()\nGet overlay regions only.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRegions\nRegions object with overlay regions {regionId: [element1, …]}\n\n\n\nRegions\n(elements can be strings for v0.x or Element objects for v1.x)\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"]}\n... })\n&gt;&gt;&gt; geo.overlay_regions()\nRegions({\n  '_border': ['M 0 0 L 100 0'],\n})\n\n\n\n\noutline.Outline.overlays()\nGet overlay region IDs from metadata.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist[str]\nList of region IDs marked as overlays\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"]}\n... })\n&gt;&gt;&gt; geo.overlays()\n['_border']\n\n\n\n\noutline.Outline.path_as_line(*region_ids)\nMark regions as lines described in path notation.\nSome SVG paths represent lines (dividers, borders, grids) rather than filled shapes. This method stores the region IDs so that stroke-only aesthetics are automatically applied.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n*region_ids\nstr\nRegion IDs containing line elements in path notation\n()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline object with line regions recorded in metadata\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0 L 100 100\"],\n...     \"_divider\": [\"M 50 0 L 50 100\"]\n... })\n&gt;&gt;&gt; geo2 = geo.path_as_line(\"_divider\")\n&gt;&gt;&gt; # Now _divider will use stroke-only rendering\n\n\n\n\noutline.Outline.region_types()\nGet aesthetic element type for each region.\nReturns a mapping of region_id -&gt; element_type where element_type is one of “shape”, “line”, or “text” for aesthetic resolution purposes.\nPriority: 1. metadata[“lines_as_path”] - explicit line override for path elements 2. Element’s element_name: - “line” → “line” - “text” → “text” - All others → “shape”\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, str]\nDict mapping region IDs to their aesthetic element types\n\n\n\n\n\n\n&gt;&gt;&gt; # v1.x format with mixed elements\n&gt;&gt;&gt; from shinymap.outline import Circle, Line, Text, Path\n&gt;&gt;&gt; outline = Outline(regions={\n...     \"region\": [Circle(cx=50, cy=50, r=30)],\n...     \"_divider\": [Line(x1=0, y1=50, x2=100, y2=50)],\n...     \"label\": [Text(x=50, y=50, text=\"A\")],\n... }, metadata={})\n&gt;&gt;&gt; outline.region_types()\n{'region': 'shape', '_divider': 'line', 'label': 'text'}\n\n&gt;&gt;&gt; # Path marked as line via path_as_line()\n&gt;&gt;&gt; outline = Outline(regions={\n...     \"_border\": [Path(d=\"M 0 0 L 100 0\")],\n... }, metadata={}).path_as_line(\"_border\")\n&gt;&gt;&gt; outline.region_types()\n{'_border': 'line'}\n\n\n\n\noutline.Outline.relabel(mapping)\nRename or merge regions (returns new Outline object).\nThis method applies relabeling transformations to create a new Outline object with renamed or merged regions. Original object is unchanged.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmapping\ndict[str, str | list[str]]\nDict mapping new IDs to old ID(s) - String value: rename single region (e.g., {“tokyo”: “path_5”}) - List value: merge multiple regions (e.g., {“hokkaido”: [“path_1”, “path_2”]})\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline object with relabeled regions\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf an old ID in mapping doesn’t exist\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"path_1\": [\"M 0 0 L 10 0\"],\n...     \"path_2\": [\"M 20 0 L 30 0\"],\n...     \"path_3\": [\"M 40 0 L 50 0\"]\n... })\n&gt;&gt;&gt; # Rename and merge\n&gt;&gt;&gt; geo2 = geo.relabel({\n...     \"region_a\": [\"path_1\", \"path_2\"],  # Merge\n...     \"_border\": \"path_3\"                 # Rename\n... })\n&gt;&gt;&gt; geo2.regions.keys()\ndict_keys(['region_a', '_border'])\n\n\n\n\noutline.Outline.set_overlays(overlay_ids)\nSet overlay region IDs in metadata (returns new Outline object).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noverlay_ids\nlist[str]\nList of region IDs to mark as overlays\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline object with updated overlay metadata\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"]\n... })\n&gt;&gt;&gt; geo2 = geo.set_overlays([\"_border\"])\n&gt;&gt;&gt; geo2.overlays()\n['_border']\n\n\n\n\noutline.Outline.to_dict()\nExport to dict in shinymap JSON format.\nAutomatically serializes elements: - v0.x format: Strings are kept as-is - v1.x format: Element objects are serialized to dicts via to_dict()\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, Any]\nDict with _metadata and region data (v0.x strings or v1.x element dicts)\n\n\n\n\n\n\n&gt;&gt;&gt; # v0.x format (strings) - empty metadata is omitted\n&gt;&gt;&gt; outline = Outline.from_dict({\"region\": [\"M 0 0\"]})\n&gt;&gt;&gt; outline.to_dict()\n{'region': ['M 0 0']}\n\n&gt;&gt;&gt; # v1.x format (elements)\n&gt;&gt;&gt; from shinymap.outline import Circle\n&gt;&gt;&gt; outline = Outline(regions={\"r1\": [Circle(cx=100, cy=100, r=50)]}, metadata={})\n&gt;&gt;&gt; outline.to_dict()\n{'r1': [{'type': 'circle', 'cx': 100, 'cy': 100, 'r': 50}]}\n\n\n\n\noutline.Outline.to_json(output_path)\nWrite outline to JSON file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noutput_path\nstr | PathType\nPath to write JSON file\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_svg(\"map.svg\")  # doctest: +SKIP\n&gt;&gt;&gt; geo.to_json(\"output.json\")  # doctest: +SKIP\n\n\n\n\noutline.Outline.underlays()\nGet underlay region IDs from metadata.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist[str]\nList of region IDs marked as underlays\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_bg\": [\"M 0 0 L 100 0 L 100 100 L 0 100 Z\"],\n...     \"_metadata\": {\"underlays\": [\"_bg\"]}\n... })\n&gt;&gt;&gt; geo.underlays()\n['_bg']\n\n\n\n\noutline.Outline.update_metadata(metadata)\nUpdate metadata (returns new Outline object).\nMerges provided metadata with existing metadata. Existing keys are overwritten by new values.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetadata\ndict[str, Any]\nDict of metadata to merge\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline object with updated metadata\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\"region\": [\"M 0 0\"]})\n&gt;&gt;&gt; geo2 = geo.update_metadata({\n...     \"source\": \"Wikimedia Commons\",\n...     \"license\": \"CC BY-SA 3.0\"\n... })\n&gt;&gt;&gt; geo2.metadata[\"source\"]\n'Wikimedia Commons'\n\n\n\n\noutline.Outline.viewbox(padding=0.02)\nGet viewBox from metadata, or compute from outline coordinates.\nWorks with both v0.x (string paths) and v1.x (Element objects).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npadding\nfloat\nPadding fraction for computed viewBox (default 2%)\n0.02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ntuple[float, float, float, float]\nViewBox tuple in format (x, y, width, height)\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\"a\": [\"M 0 0 L 100 100\"]})\n&gt;&gt;&gt; geo.viewbox()  # Returns with 2% padding\n(-2.0, -2.0, 104.0, 104.0)"
  },
  {
    "objectID": "python/outline.Outline.html#attributes",
    "href": "python/outline.Outline.html#attributes",
    "title": "outline.Outline",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nregions\nRegions\nRegions object (dict subclass) mapping region IDs to lists of elements (str for v0.x compatibility, Element objects for v1.x)\n\n\nmetadata\ndict[str, Any]\nOptional metadata dict (viewBox, overlays, source, license, etc.)"
  },
  {
    "objectID": "python/outline.Outline.html#note-on-aesthetics",
    "href": "python/outline.Outline.html#note-on-aesthetics",
    "title": "outline.Outline",
    "section": "",
    "text": "SVG elements preserve aesthetic attributes (fill, stroke, etc.) but these are NOT used by shinymap for rendering. Interactive appearance is controlled via Python API. Preserved values are for SVG export and reference only."
  },
  {
    "objectID": "python/outline.Outline.html#examples",
    "href": "python/outline.Outline.html#examples",
    "title": "outline.Outline",
    "section": "",
    "text": "&gt;&gt;&gt; # v0.x format (backward compatible)\n&gt;&gt;&gt; data = {\"region1\": [\"M 0 0 L 10 0\"], \"_metadata\": {\"viewBox\": \"0 0 100 100\"}}\n&gt;&gt;&gt; geo = Outline.from_dict(data)\n\n&gt;&gt;&gt; # v1.x format (polymorphic elements)\n&gt;&gt;&gt; from shinymap.outline import Circle\n&gt;&gt;&gt; geo = Outline(regions={\"r1\": [Circle(cx=100, cy=100, r=50)]}, metadata={})"
  },
  {
    "objectID": "python/outline.Outline.html#methods",
    "href": "python/outline.Outline.html#methods",
    "title": "outline.Outline",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfrom_dict\nLoad outline from dict (supports v0.x strings and v1.x element dicts).\n\n\nfrom_json\nLoad outline from JSON file.\n\n\nfrom_svg\nExtract outline from SVG file (all element types).\n\n\ngroups\nGet group membership from metadata.\n\n\nhidden\nGet hidden region IDs from metadata.\n\n\nlayers_dict\nGet layers configuration dict for JavaScript props.\n\n\nmain_regions\nGet main regions (excluding overlays).\n\n\nmerge_layers\nMerge provided layers with outline’s metadata overlays.\n\n\nmetadata_dict\nBuild outline metadata dict for JavaScript props.\n\n\noverlay_regions\nGet overlay regions only.\n\n\noverlays\nGet overlay region IDs from metadata.\n\n\npath_as_line\nMark regions as lines described in path notation.\n\n\nregion_types\nGet aesthetic element type for each region.\n\n\nrelabel\nRename or merge regions (returns new Outline object).\n\n\nset_overlays\nSet overlay region IDs in metadata (returns new Outline object).\n\n\nto_dict\nExport to dict in shinymap JSON format.\n\n\nto_json\nWrite outline to JSON file.\n\n\nunderlays\nGet underlay region IDs from metadata.\n\n\nupdate_metadata\nUpdate metadata (returns new Outline object).\n\n\nviewbox\nGet viewBox from metadata, or compute from outline coordinates.\n\n\n\n\n\noutline.Outline.from_dict(data)\nLoad outline from dict (supports v0.x strings and v1.x element dicts).\nAutomatically detects format and converts: - v0.x: String paths → kept as strings (backward compatible) - v1.x: Element dicts → deserialized to Element objects\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\ndict[str, Any]\nDictionary with regions and optional _metadata key\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nOutline object with normalized list-based regions\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf _metadata exists but is not a dict\n\n\n\n\n\n\n&gt;&gt;&gt; # v0.x string format (backward compatible)\n&gt;&gt;&gt; outline = Outline.from_dict({\"a\": \"M 0 0 L 10 0\"})\n&gt;&gt;&gt; list(outline.regions.keys())\n['a']\n\n&gt;&gt;&gt; # v0.x list format\n&gt;&gt;&gt; outline = Outline.from_dict({\"a\": [\"M 0 0\", \"L 10 0\"]})\n&gt;&gt;&gt; outline.regions[\"a\"]\n['M 0 0', 'L 10 0']\n\n&gt;&gt;&gt; # v1.x element format\n&gt;&gt;&gt; data = {\"a\": [{\"type\": \"circle\", \"cx\": 100, \"cy\": 100, \"r\": 50}]}\n&gt;&gt;&gt; outline = Outline.from_dict(data)\n&gt;&gt;&gt; outline.regions[\"a\"]\n[Circle(cx=100, cy=100, r=50)]\n\n\n\n\noutline.Outline.from_json(json_path)\nLoad outline from JSON file.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\njson_path\nstr | PathType\nPath to JSON file in shinymap format\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nOutline object with normalized list-based paths\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_json(\"japan_prefectures.json\")  # doctest: +SKIP\n&gt;&gt;&gt; geo.regions.keys()  # doctest: +SKIP\ndict_keys(['01', '02', ...])\n\n\n\n\noutline.Outline.from_svg(svg_path, extract_viewbox=True)\nExtract outline from SVG file (all element types).\nExtracts all supported SVG shape elements (path, circle, rect, polygon, ellipse, line, text) and generates auto-IDs for elements without IDs. This is v1.0 behavior - returns polymorphic Element objects instead of path strings.\nPreserves SVG aesthetics (fill, stroke, etc.) but these are NOT used by shinymap for rendering. See class docstring for details.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsvg_path\nstr | PathType\nPath to input SVG file\nrequired\n\n\nextract_viewbox\nbool\nIf True, extract viewBox from SVG root element\nTrue\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nOutline object with extracted elements (v1.x format)\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nFileNotFoundError\nIf svg_path does not exist\n\n\n\nValueError\nIf SVG parsing fails\n\n\n\n\n\n\n&gt;&gt;&gt; # Basic extraction (all element types)\n&gt;&gt;&gt; geo = Outline.from_svg(\"design.svg\")  # doctest: +SKIP\n&gt;&gt;&gt; geo.regions.keys()  # doctest: +SKIP\ndict_keys(['circle_1', 'rect_1', 'path_1', 'text_1'])\n\n&gt;&gt;&gt; # With transformations\n&gt;&gt;&gt; geo = Outline.from_svg(\"map.svg\")  # doctest: +SKIP\n&gt;&gt;&gt; geo.relabel({\"hokkaido\": [\"circle_1\", \"circle_2\"]})  # doctest: +SKIP\n&gt;&gt;&gt; geo.set_overlays([\"_border\"])  # doctest: +SKIP\n&gt;&gt;&gt; geo.to_json(\"output.json\")  # doctest: +SKIP\n\n\n\n\noutline.Outline.groups()\nGet group membership from metadata.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, list[str]]\nDict mapping group names to lists of region IDs\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region1\": [\"M 0 0\"],\n...     \"region2\": [\"M 10 0\"],\n...     \"_metadata\": {\"groups\": {\"coastal\": [\"region1\", \"region2\"]}}\n... })\n&gt;&gt;&gt; geo.groups()\n{'coastal': ['region1', 'region2']}\n\n\n\n\noutline.Outline.hidden()\nGet hidden region IDs from metadata.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist[str]\nList of region IDs marked as hidden\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_temp\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"hidden\": [\"_temp\"]}\n... })\n&gt;&gt;&gt; geo.hidden()\n['_temp']\n\n\n\n\noutline.Outline.layers_dict()\nGet layers configuration dict for JavaScript props.\nReturns a dict with overlays, underlays, and hidden keys if any layer configuration is present in metadata. Returns None if no layer configuration exists.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, list[str]] | None\nDict with layer configuration or None\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"], \"underlays\": [\"_bg\"]}\n... })\n&gt;&gt;&gt; geo.layers_dict()\n{'overlays': ['_border'], 'underlays': ['_bg']}\n\n\n\n\noutline.Outline.main_regions()\nGet main regions (excluding overlays).\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRegions\nRegions object with main regions {regionId: [element1, …]}\n\n\n\nRegions\n(elements can be strings for v0.x or Element objects for v1.x)\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"]}\n... })\n&gt;&gt;&gt; geo.main_regions()\nRegions({\n  'region': ['M 0 0'],\n})\n\n\n\n\noutline.Outline.merge_layers(layers)\nMerge provided layers with outline’s metadata overlays.\nReturns a new Outline with updated metadata containing the merged layers configuration. Explicit layers take priority over metadata overlays.\nThis method follows the immutable pattern - the original Outline is unchanged and a new Outline is returned.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlayers\ndict[str, list[str]] | None\nOptional explicit layer configuration with keys: underlays, overlays, hidden\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline with merged layers in metadata\n\n\n\n\n\n\n&gt;&gt;&gt; outline = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"]}\n... })\n&gt;&gt;&gt; merged = outline.merge_layers({\"underlays\": [\"_bg\"]})\n&gt;&gt;&gt; merged.metadata\n{'overlays': ['_border'], 'underlays': ['_bg']}\n&gt;&gt;&gt; merged = outline.merge_layers({\"overlays\": [\"_custom\"]})\n&gt;&gt;&gt; merged.metadata\n{'overlays': ['_custom']}\n\n\n\n\noutline.Outline.metadata_dict(view_box=None)\nBuild outline metadata dict for JavaScript props.\nCreates the outlineMetadata object sent to React components, containing viewBox and groups information.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nview_box\ntuple[float, float, float, float] | None\nOptional override viewBox tuple. If None, uses self.viewbox()\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, Any] | None\nDict with viewBox and groups, or None if no metadata\n\n\n\n\n\n\n&gt;&gt;&gt; outline = Outline.from_dict({\n...     \"region1\": [\"M 0 0 L 100 100\"],\n...     \"_metadata\": {\"groups\": {\"coastal\": [\"region1\"]}}\n... })\n&gt;&gt;&gt; outline.metadata_dict()\n{'viewBox': '-2.0 -2.0 104.0 104.0', 'groups': {'coastal': ['region1']}}\n\n\n\n\noutline.Outline.overlay_regions()\nGet overlay regions only.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRegions\nRegions object with overlay regions {regionId: [element1, …]}\n\n\n\nRegions\n(elements can be strings for v0.x or Element objects for v1.x)\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"]}\n... })\n&gt;&gt;&gt; geo.overlay_regions()\nRegions({\n  '_border': ['M 0 0 L 100 0'],\n})\n\n\n\n\noutline.Outline.overlays()\nGet overlay region IDs from metadata.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist[str]\nList of region IDs marked as overlays\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"],\n...     \"_metadata\": {\"overlays\": [\"_border\"]}\n... })\n&gt;&gt;&gt; geo.overlays()\n['_border']\n\n\n\n\noutline.Outline.path_as_line(*region_ids)\nMark regions as lines described in path notation.\nSome SVG paths represent lines (dividers, borders, grids) rather than filled shapes. This method stores the region IDs so that stroke-only aesthetics are automatically applied.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n*region_ids\nstr\nRegion IDs containing line elements in path notation\n()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline object with line regions recorded in metadata\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0 L 100 100\"],\n...     \"_divider\": [\"M 50 0 L 50 100\"]\n... })\n&gt;&gt;&gt; geo2 = geo.path_as_line(\"_divider\")\n&gt;&gt;&gt; # Now _divider will use stroke-only rendering\n\n\n\n\noutline.Outline.region_types()\nGet aesthetic element type for each region.\nReturns a mapping of region_id -&gt; element_type where element_type is one of “shape”, “line”, or “text” for aesthetic resolution purposes.\nPriority: 1. metadata[“lines_as_path”] - explicit line override for path elements 2. Element’s element_name: - “line” → “line” - “text” → “text” - All others → “shape”\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, str]\nDict mapping region IDs to their aesthetic element types\n\n\n\n\n\n\n&gt;&gt;&gt; # v1.x format with mixed elements\n&gt;&gt;&gt; from shinymap.outline import Circle, Line, Text, Path\n&gt;&gt;&gt; outline = Outline(regions={\n...     \"region\": [Circle(cx=50, cy=50, r=30)],\n...     \"_divider\": [Line(x1=0, y1=50, x2=100, y2=50)],\n...     \"label\": [Text(x=50, y=50, text=\"A\")],\n... }, metadata={})\n&gt;&gt;&gt; outline.region_types()\n{'region': 'shape', '_divider': 'line', 'label': 'text'}\n\n&gt;&gt;&gt; # Path marked as line via path_as_line()\n&gt;&gt;&gt; outline = Outline(regions={\n...     \"_border\": [Path(d=\"M 0 0 L 100 0\")],\n... }, metadata={}).path_as_line(\"_border\")\n&gt;&gt;&gt; outline.region_types()\n{'_border': 'line'}\n\n\n\n\noutline.Outline.relabel(mapping)\nRename or merge regions (returns new Outline object).\nThis method applies relabeling transformations to create a new Outline object with renamed or merged regions. Original object is unchanged.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmapping\ndict[str, str | list[str]]\nDict mapping new IDs to old ID(s) - String value: rename single region (e.g., {“tokyo”: “path_5”}) - List value: merge multiple regions (e.g., {“hokkaido”: [“path_1”, “path_2”]})\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline object with relabeled regions\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf an old ID in mapping doesn’t exist\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"path_1\": [\"M 0 0 L 10 0\"],\n...     \"path_2\": [\"M 20 0 L 30 0\"],\n...     \"path_3\": [\"M 40 0 L 50 0\"]\n... })\n&gt;&gt;&gt; # Rename and merge\n&gt;&gt;&gt; geo2 = geo.relabel({\n...     \"region_a\": [\"path_1\", \"path_2\"],  # Merge\n...     \"_border\": \"path_3\"                 # Rename\n... })\n&gt;&gt;&gt; geo2.regions.keys()\ndict_keys(['region_a', '_border'])\n\n\n\n\noutline.Outline.set_overlays(overlay_ids)\nSet overlay region IDs in metadata (returns new Outline object).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noverlay_ids\nlist[str]\nList of region IDs to mark as overlays\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline object with updated overlay metadata\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_border\": [\"M 0 0 L 100 0\"]\n... })\n&gt;&gt;&gt; geo2 = geo.set_overlays([\"_border\"])\n&gt;&gt;&gt; geo2.overlays()\n['_border']\n\n\n\n\noutline.Outline.to_dict()\nExport to dict in shinymap JSON format.\nAutomatically serializes elements: - v0.x format: Strings are kept as-is - v1.x format: Element objects are serialized to dicts via to_dict()\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, Any]\nDict with _metadata and region data (v0.x strings or v1.x element dicts)\n\n\n\n\n\n\n&gt;&gt;&gt; # v0.x format (strings) - empty metadata is omitted\n&gt;&gt;&gt; outline = Outline.from_dict({\"region\": [\"M 0 0\"]})\n&gt;&gt;&gt; outline.to_dict()\n{'region': ['M 0 0']}\n\n&gt;&gt;&gt; # v1.x format (elements)\n&gt;&gt;&gt; from shinymap.outline import Circle\n&gt;&gt;&gt; outline = Outline(regions={\"r1\": [Circle(cx=100, cy=100, r=50)]}, metadata={})\n&gt;&gt;&gt; outline.to_dict()\n{'r1': [{'type': 'circle', 'cx': 100, 'cy': 100, 'r': 50}]}\n\n\n\n\noutline.Outline.to_json(output_path)\nWrite outline to JSON file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noutput_path\nstr | PathType\nPath to write JSON file\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_svg(\"map.svg\")  # doctest: +SKIP\n&gt;&gt;&gt; geo.to_json(\"output.json\")  # doctest: +SKIP\n\n\n\n\noutline.Outline.underlays()\nGet underlay region IDs from metadata.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist[str]\nList of region IDs marked as underlays\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\n...     \"region\": [\"M 0 0\"],\n...     \"_bg\": [\"M 0 0 L 100 0 L 100 100 L 0 100 Z\"],\n...     \"_metadata\": {\"underlays\": [\"_bg\"]}\n... })\n&gt;&gt;&gt; geo.underlays()\n['_bg']\n\n\n\n\noutline.Outline.update_metadata(metadata)\nUpdate metadata (returns new Outline object).\nMerges provided metadata with existing metadata. Existing keys are overwritten by new values.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetadata\ndict[str, Any]\nDict of metadata to merge\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutline\nNew Outline object with updated metadata\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\"region\": [\"M 0 0\"]})\n&gt;&gt;&gt; geo2 = geo.update_metadata({\n...     \"source\": \"Wikimedia Commons\",\n...     \"license\": \"CC BY-SA 3.0\"\n... })\n&gt;&gt;&gt; geo2.metadata[\"source\"]\n'Wikimedia Commons'\n\n\n\n\noutline.Outline.viewbox(padding=0.02)\nGet viewBox from metadata, or compute from outline coordinates.\nWorks with both v0.x (string paths) and v1.x (Element objects).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npadding\nfloat\nPadding fraction for computed viewBox (default 2%)\n0.02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ntuple[float, float, float, float]\nViewBox tuple in format (x, y, width, height)\n\n\n\n\n\n\n&gt;&gt;&gt; geo = Outline.from_dict({\"a\": [\"M 0 0 L 100 100\"]})\n&gt;&gt;&gt; geo.viewbox()  # Returns with 2% padding\n(-2.0, -2.0, 104.0, 104.0)"
  },
  {
    "objectID": "python/preview_region.html",
    "href": "python/preview_region.html",
    "title": "preview_region",
    "section": "",
    "text": "preview_region(state, config)\nPreview the aesthetic resolution for a region with verbose output.\nShows how aesthetics are inherited and resolved at each layer, displaying ALL properties at each step.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstate\nRegionState\nThe region’s current state\nrequired\n\n\nconfig\nAestheticConfig\nThe aesthetic configuration\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nA formatted string showing the resolution at each layer\n\n\n\n\n\n\n&gt;&gt;&gt; from shinymap import aes, PARENT, preview_region, RegionState, AestheticConfig\n&gt;&gt;&gt; state = RegionState(\"region_1\", value=1, is_hovered=True)  # value=1 means selected\n&gt;&gt;&gt; config = AestheticConfig(\n...     aes_base=aes.Shape(stroke_width=2),\n...     aes_select=aes.Shape(stroke_width=3),\n...     aes_hover=aes.Shape(stroke_width=PARENT.stroke_width + 1),\n... )\n&gt;&gt;&gt; print(preview_region(state, config))  # doctest: +SKIP"
  },
  {
    "objectID": "python/preview_region.html#parameters",
    "href": "python/preview_region.html#parameters",
    "title": "preview_region",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nstate\nRegionState\nThe region’s current state\nrequired\n\n\nconfig\nAestheticConfig\nThe aesthetic configuration\nrequired"
  },
  {
    "objectID": "python/preview_region.html#returns",
    "href": "python/preview_region.html#returns",
    "title": "preview_region",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nstr\nA formatted string showing the resolution at each layer"
  },
  {
    "objectID": "python/preview_region.html#examples",
    "href": "python/preview_region.html#examples",
    "title": "preview_region",
    "section": "",
    "text": "&gt;&gt;&gt; from shinymap import aes, PARENT, preview_region, RegionState, AestheticConfig\n&gt;&gt;&gt; state = RegionState(\"region_1\", value=1, is_hovered=True)  # value=1 means selected\n&gt;&gt;&gt; config = AestheticConfig(\n...     aes_base=aes.Shape(stroke_width=2),\n...     aes_select=aes.Shape(stroke_width=3),\n...     aes_hover=aes.Shape(stroke_width=PARENT.stroke_width + 1),\n... )\n&gt;&gt;&gt; print(preview_region(state, config))  # doctest: +SKIP"
  },
  {
    "objectID": "python/resolve_region.html",
    "href": "python/resolve_region.html",
    "title": "resolve_region",
    "section": "",
    "text": "resolve_region(state, config)\nResolve the final aesthetic for a region given its state.\n\n\nDEFAULT → BASE → GROUP → SELECT (if selected) → HOVER (if hovered)\nEach layer merges onto the previous, with RelativeExpr values resolved against the parent layer’s values.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstate\nRegionState\nThe region’s current state (selected, hovered, group)\nrequired\n\n\nconfig\nAestheticConfig\nThe aesthetic configuration (base, select, hover, group aesthetics)\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nShapeAesthetic\nA fully resolved ShapeAesthetic with all properties set\n\n\n\n\n\n\n&gt;&gt;&gt; from shinymap import aes, PARENT, resolve_region, RegionState, AestheticConfig\n&gt;&gt;&gt; state = RegionState(\"region_1\", value=1, is_hovered=True)  # value=1 means selected\n&gt;&gt;&gt; config = AestheticConfig(\n...     aes_base=aes.Shape(stroke_width=2),\n...     aes_select=aes.Shape(stroke_width=3, fill_color=\"#fef08a\"),\n...     aes_hover=aes.Shape(stroke_width=PARENT.stroke_width + 1),\n... )\n&gt;&gt;&gt; resolved = resolve_region(state, config)\n&gt;&gt;&gt; resolved.stroke_width  # 3 (from select) + 1 (from hover) = 4\n4.0"
  },
  {
    "objectID": "python/resolve_region.html#this-function-walks-the-aesthetic-hierarchy-recursively",
    "href": "python/resolve_region.html#this-function-walks-the-aesthetic-hierarchy-recursively",
    "title": "resolve_region",
    "section": "",
    "text": "DEFAULT → BASE → GROUP → SELECT (if selected) → HOVER (if hovered)\nEach layer merges onto the previous, with RelativeExpr values resolved against the parent layer’s values."
  },
  {
    "objectID": "python/resolve_region.html#parameters",
    "href": "python/resolve_region.html#parameters",
    "title": "resolve_region",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nstate\nRegionState\nThe region’s current state (selected, hovered, group)\nrequired\n\n\nconfig\nAestheticConfig\nThe aesthetic configuration (base, select, hover, group aesthetics)\nrequired"
  },
  {
    "objectID": "python/resolve_region.html#returns",
    "href": "python/resolve_region.html#returns",
    "title": "resolve_region",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nShapeAesthetic\nA fully resolved ShapeAesthetic with all properties set"
  },
  {
    "objectID": "python/resolve_region.html#examples",
    "href": "python/resolve_region.html#examples",
    "title": "resolve_region",
    "section": "",
    "text": "&gt;&gt;&gt; from shinymap import aes, PARENT, resolve_region, RegionState, AestheticConfig\n&gt;&gt;&gt; state = RegionState(\"region_1\", value=1, is_hovered=True)  # value=1 means selected\n&gt;&gt;&gt; config = AestheticConfig(\n...     aes_base=aes.Shape(stroke_width=2),\n...     aes_select=aes.Shape(stroke_width=3, fill_color=\"#fef08a\"),\n...     aes_hover=aes.Shape(stroke_width=PARENT.stroke_width + 1),\n... )\n&gt;&gt;&gt; resolved = resolve_region(state, config)\n&gt;&gt;&gt; resolved.stroke_width  # 3 (from select) + 1 (from hover) = 4\n4.0"
  },
  {
    "objectID": "vignettes/getting-started.html",
    "href": "vignettes/getting-started.html",
    "title": "Getting Started",
    "section": "",
    "text": "This guide walks you through creating your first interactive map with shinymap."
  },
  {
    "objectID": "vignettes/getting-started.html#installation",
    "href": "vignettes/getting-started.html#installation",
    "title": "Getting Started",
    "section": "Installation",
    "text": "Installation\npip install shinymap\nOr with uv:\nuv add shinymap"
  },
  {
    "objectID": "vignettes/getting-started.html#basic-example",
    "href": "vignettes/getting-started.html#basic-example",
    "title": "Getting Started",
    "section": "Basic Example",
    "text": "Basic Example\nfrom shiny import App, ui\nfrom shinymap import input_map, output_map, render_map, Map\nfrom shinymap.outline import Outline\n\n# Define simple geometry\nOUTLINE = Outline.from_dict({\n    \"region_a\": [{\"type\": \"rect\", \"x\": 10, \"y\": 10, \"width\": 30, \"height\": 30}],\n    \"region_b\": [{\"type\": \"rect\", \"x\": 50, \"y\": 10, \"width\": 30, \"height\": 30}],\n    \"region_c\": [{\"type\": \"rect\", \"x\": 30, \"y\": 50, \"width\": 30, \"height\": 30}],\n    \"_metadata\": {\"viewBox\": \"0 0 100 100\"},\n})\n\napp_ui = ui.page_fluid(\n    ui.h2(\"My First Map\"),\n    input_map(\"selection\", OUTLINE, mode=\"single\"),\n    ui.output_text(\"selected\"),\n)\n\ndef server(input, output, session):\n    @output\n    @render.text\n    def selected():\n        return f\"Selected: {input.selection()}\"\n\napp = App(app_ui, server)"
  },
  {
    "objectID": "vignettes/getting-started.html#next-steps",
    "href": "vignettes/getting-started.html#next-steps",
    "title": "Getting Started",
    "section": "Next Steps",
    "text": "Next Steps\n\nLearn about selection modes\nCustomize appearance with aesthetics\nLoad real geometry from SVG files"
  },
  {
    "objectID": "typescript/index.html",
    "href": "typescript/index.html",
    "title": "shinymap TypeScript API",
    "section": "",
    "text": "shinymap TypeScript API"
  },
  {
    "objectID": "typescript/index.html#type-aliases",
    "href": "typescript/index.html#type-aliases",
    "title": "shinymap TypeScript API",
    "section": "Type Aliases",
    "text": "Type Aliases\n\nAesConfig\nInputMapProps\nLayersConfig\nMapModeType\nModeConfig\nOutputMapProps\nRegionId\nRegionsMap\nTooltipMap"
  },
  {
    "objectID": "typescript/index.html#variables",
    "href": "typescript/index.html#variables",
    "title": "shinymap TypeScript API",
    "section": "Variables",
    "text": "Variables\n\nneutrals\npalette\nqualitative\nsequential"
  },
  {
    "objectID": "typescript/index.html#functions",
    "href": "typescript/index.html#functions",
    "title": "shinymap TypeScript API",
    "section": "Functions",
    "text": "Functions\n\nInputMap\nOutputMap\nrenderInputMap\nrenderOutputMap"
  },
  {
    "objectID": "typescript/functions/OutputMap.html",
    "href": "typescript/functions/OutputMap.html",
    "title": "Function: OutputMap()",
    "section": "",
    "text": "shinymap TypeScript API\nshinymap TypeScript API / OutputMap"
  },
  {
    "objectID": "typescript/functions/OutputMap.html#parameters",
    "href": "typescript/functions/OutputMap.html#parameters",
    "title": "Function: OutputMap()",
    "section": "Parameters",
    "text": "Parameters\n\nprops\nOutputMapProps"
  },
  {
    "objectID": "typescript/functions/OutputMap.html#returns",
    "href": "typescript/functions/OutputMap.html#returns",
    "title": "Function: OutputMap()",
    "section": "Returns",
    "text": "Returns\nElement"
  },
  {
    "objectID": "typescript/functions/renderOutputMap.html",
    "href": "typescript/functions/renderOutputMap.html",
    "title": "Function: renderOutputMap()",
    "section": "",
    "text": "shinymap TypeScript API\nshinymap TypeScript API / renderOutputMap"
  },
  {
    "objectID": "typescript/functions/renderOutputMap.html#parameters",
    "href": "typescript/functions/renderOutputMap.html#parameters",
    "title": "Function: renderOutputMap()",
    "section": "Parameters",
    "text": "Parameters\n\ntarget\nHTMLElement\n\n\nprops\nOutputMapProps"
  },
  {
    "objectID": "typescript/functions/renderOutputMap.html#returns",
    "href": "typescript/functions/renderOutputMap.html#returns",
    "title": "Function: renderOutputMap()",
    "section": "Returns",
    "text": "Returns\nRoot"
  },
  {
    "objectID": "typescript/type-aliases/InputMapProps.html",
    "href": "typescript/type-aliases/InputMapProps.html",
    "title": "Type Alias: InputMapProps",
    "section": "",
    "text": "shinymap TypeScript API\nshinymap TypeScript API / InputMapProps"
  },
  {
    "objectID": "typescript/type-aliases/InputMapProps.html#properties",
    "href": "typescript/type-aliases/InputMapProps.html#properties",
    "title": "Type Alias: InputMapProps",
    "section": "Properties",
    "text": "Properties\n\naes?\n\noptional aes: AesConfig\n\nDefined in: types.ts:713\nNested aesthetic configuration.\n\n\n\nclassName?\n\noptional className: string\n\nDefined in: types.ts:703\n\n\n\ncontainerStyle?\n\noptional containerStyle: React.CSSProperties\n\nDefined in: types.ts:704\n\n\n\nfillColor?\n\noptional fillColor: FillMap\n\nDefined in: types.ts:701\n\n\n\nlayers?\n\noptional layers: LayersConfig\n\nDefined in: types.ts:717\nNested layer configuration.\n\n\n\nmode?\n\noptional mode: MapModeType | ModeConfig\n\nDefined in: types.ts:709\nMode configuration. Can be a string shorthand (“single”, “multiple”, “count”, “cycle”) or a full ModeConfig object for advanced options.\n\n\n\nonChange()?\n\noptional onChange: (value) =&gt; void\n\nDefined in: types.ts:723\n\nParameters\n\nvalue\nRecord&lt;RegionId, number&gt;\n\n\n\nReturns\nvoid\n\n\n\n\noutlineMetadata?\n\noptional outlineMetadata: OutlineMetadata\n\nDefined in: types.ts:721\nOutline metadata containing group definitions.\n\n\n\nraw?\n\noptional raw: boolean\n\nDefined in: types.ts:731\nIf true, return raw dict value to Shiny instead of transformed types. When false (default), single mode returns string|null, multiple returns string[]. When true, all modes return Record&lt;RegionId, number&gt;.\n\n\n\nregionProps()?\n\noptional regionProps: (args) =&gt; React.SVGProps&lt;SVGPathElement&gt;\n\nDefined in: types.ts:725\n\nParameters\n\nargs\nResolveAestheticArgs\n\n\n\nReturns\nReact.SVGProps&lt;SVGPathElement&gt;\n\n\n\n\nregions\n\nregions: RegionsMap\n\nDefined in: types.ts:699\n\n\n\nresolveAesthetic()?\n\noptional resolveAesthetic: (args) =&gt; AestheticStyle | undefined\n\nDefined in: types.ts:724\n\nParameters\n\nargs\nResolveAestheticArgs\n\n\n\nReturns\nAestheticStyle | undefined\n\n\n\n\ntooltips?\n\noptional tooltips: TooltipMap\n\nDefined in: types.ts:700\n\n\n\nvalue?\n\noptional value: Record&lt;RegionId, number&gt;\n\nDefined in: types.ts:722\n\n\n\nviewBox?\n\noptional viewBox: string\n\nDefined in: types.ts:702"
  },
  {
    "objectID": "typescript/type-aliases/MapModeType.html",
    "href": "typescript/type-aliases/MapModeType.html",
    "title": "Type Alias: MapModeType",
    "section": "",
    "text": "shinymap TypeScript API\n\nshinymap TypeScript API / MapModeType\n\nType Alias: MapModeType\n\nMapModeType = \"single\" | \"multiple\" | \"count\" | \"cycle\" | \"display\"\n\nDefined in: types.ts:143"
  },
  {
    "objectID": "typescript/type-aliases/OutputMapProps.html",
    "href": "typescript/type-aliases/OutputMapProps.html",
    "title": "Type Alias: OutputMapProps",
    "section": "",
    "text": "shinymap TypeScript API\nshinymap TypeScript API / OutputMapProps"
  },
  {
    "objectID": "typescript/type-aliases/OutputMapProps.html#properties",
    "href": "typescript/type-aliases/OutputMapProps.html#properties",
    "title": "Type Alias: OutputMapProps",
    "section": "Properties",
    "text": "Properties\n\naes?\n\noptional aes: AesConfig\n\nDefined in: types.ts:757\nNested aesthetic configuration.\n\n\n\nclassName?\n\noptional className: string\n\nDefined in: types.ts:746\n\n\n\ncontainerStyle?\n\noptional containerStyle: React.CSSProperties\n\nDefined in: types.ts:747\n\n\n\nfillColor?\n\noptional fillColor: string | Record&lt;RegionId, string&gt;\n\nDefined in: types.ts:766\n\n\n\nfillOpacity?\n\noptional fillOpacity: number | Record&lt;RegionId, number&gt;\n\nDefined in: types.ts:769\n\n\n\nlayers?\n\noptional layers: LayersConfig\n\nDefined in: types.ts:761\nNested layer configuration.\n\n\n\nmode?\n\noptional mode: MapModeType | ModeConfig\n\nDefined in: types.ts:753\nMode configuration. For output maps, typically “display” mode. Display mode enables hover but disables click, and uses indexed aesthetics to map values to visual styles.\n\n\n\nonRegionClick()?\n\noptional onRegionClick: (id) =&gt; void\n\nDefined in: types.ts:775\n\nParameters\n\nid\nRegionId\n\n\n\nReturns\nvoid\n\n\n\n\noutlineMetadata?\n\noptional outlineMetadata: OutlineMetadata\n\nDefined in: types.ts:765\nOutline metadata containing group definitions.\n\n\n\nregionProps()?\n\noptional regionProps: (args) =&gt; React.SVGProps&lt;SVGPathElement&gt;\n\nDefined in: types.ts:777\n\nParameters\n\nargs\nResolveOutputAestheticArgs\n\n\n\nReturns\nReact.SVGProps&lt;SVGPathElement&gt;\n\n\n\n\nregions\n\nregions: RegionsMap\n\nDefined in: types.ts:743\n\n\n\nresolveAesthetic()?\n\noptional resolveAesthetic: (args) =&gt; AestheticStyle | undefined\n\nDefined in: types.ts:776\n\nParameters\n\nargs\nResolveOutputAestheticArgs\n\n\n\nReturns\nAestheticStyle | undefined\n\n\n\n\nstrokeColor?\n\noptional strokeColor: string | Record&lt;RegionId, string&gt;\n\nDefined in: types.ts:768\n\n\n\nstrokeWidth?\n\noptional strokeWidth: number | Record&lt;RegionId, number&gt;\n\nDefined in: types.ts:767\n\n\n\ntooltips?\n\noptional tooltips: TooltipMap\n\nDefined in: types.ts:744\n\n\n\nvalue?\n\noptional value: Record&lt;RegionId, number&gt;\n\nDefined in: types.ts:774\nRegion values (counts). Selection is derived from value &gt; 0. For display mode, values index into the aesIndexed arrays.\n\n\n\nviewBox?\n\noptional viewBox: string\n\nDefined in: types.ts:745"
  },
  {
    "objectID": "typescript/type-aliases/RegionsMap.html",
    "href": "typescript/type-aliases/RegionsMap.html",
    "title": "Type Alias: RegionsMap",
    "section": "",
    "text": "shinymap TypeScript API\n\nshinymap TypeScript API / RegionsMap\n\nType Alias: RegionsMap\n\nRegionsMap = Record&lt;RegionId, string | string[] | Element | Element[]&gt;\n\nDefined in: types.ts:137\nRegions map supports both v0.x (string paths) and v1.x (polymorphic elements): - v0.x: string | string[] (treated as path elements) - v1.x: Element | Element[] (any SVG element type)\nExamples: v0.x: { “region1”: “M 0 0 L 10 10” } v0.x: { “region1”: [“M 0 0 L 10 10”, “M 20 20 L 30 30”] } v1.x: { “region1”: { type: “circle”, cx: 50, cy: 50, r: 30 } } v1.x: { “region1”: [{ type: “circle”, … }, { type: “rect”, … }] }"
  },
  {
    "objectID": "typescript/variables/neutrals.html",
    "href": "typescript/variables/neutrals.html",
    "title": "Variable: neutrals",
    "section": "",
    "text": "shinymap TypeScript API\nshinymap TypeScript API / neutrals"
  },
  {
    "objectID": "typescript/variables/neutrals.html#type-declaration",
    "href": "typescript/variables/neutrals.html#type-declaration",
    "title": "Variable: neutrals",
    "section": "Type Declaration",
    "text": "Type Declaration\n\nfill\n\nfill: string = \"#e2e8f0\"\n\n\n\nstroke\n\nstroke: string = \"#1f2937\"\n\n\n\nstrokeActive\n\nstrokeActive: string = \"#0f172a\""
  },
  {
    "objectID": "typescript/variables/qualitative.html",
    "href": "typescript/variables/qualitative.html",
    "title": "Variable: qualitative",
    "section": "",
    "text": "shinymap TypeScript API\n\nshinymap TypeScript API / qualitative\n\nVariable: qualitative\n\nconst qualitative: string[]\n\nDefined in: palette.ts:8"
  }
]